<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="google" content="notranslate" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SAF: framework/modules/saf_utilities/saf_utility_veclib.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-498Z1C2LX5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-498Z1C2LX5');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SAF
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('saf__utility__veclib_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">saf_utility_veclib.c File Reference<div class="ingroups"><a class="el" href="group___utilities.html">saf_utilities</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Wrappers for optimised linear algebra routines, utilising CBLAS and LAPACK, and/or SIMD intrinsics.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="saf__utilities_8h_source.html">saf_utilities.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="saf__externals_8h_source.html">saf_externals.h</a>&quot;</code><br />
</div>
<p><a href="saf__utility__veclib_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__ssvd__data.html">utility_ssvd_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga4bc9fb7cc785506dc196d48c04ded6ea" title="Singular value decomposition: single precision, i.e.">utility_ssvd()</a>  <a href="structutility__ssvd__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__csvd__data.html">utility_csvd_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga87c408fda14dfb4e3cf83ac29fe25b6b" title="Singular value decomposition: single precision complex, i.e.">utility_csvd()</a>  <a href="structutility__csvd__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__sseig__data.html">utility_sseig_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#gaa8246221927b40b174603801e00acf6c" title="Eigenvalue decomposition of a SYMMETRIC matrix: single precision, i.e.">utility_sseig()</a>  <a href="structutility__sseig__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__cseig__data.html">utility_cseig_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga8641e94f44ce883e136db7315e8dccb3" title="Eigenvalue decomposition of a SYMMETRIC/HERMITION matrix: single precision complex,...">utility_cseig()</a>  <a href="structutility__cseig__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__ceigmp__data.html">utility_ceigmp_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga0c0617eefc40f9dfe46a5d76c9a39b6d" title="Computes eigenvalues of a matrix pair using the QZ method, single precision complex,...">utility_ceigmp()</a>  <a href="structutility__ceigmp__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__zeigmp__data.html">utility_zeigmp_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga56a643599c5f23e6e04a0d59306bbbc3" title="Computes eigenvalues of a matrix pair using the QZ method, double precision complex,...">utility_zeigmp()</a>  <a href="structutility__zeigmp__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__ceig__data.html">utility_ceig_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga5baae978beb557f6642f3fcd78caa1dd" title="Eigenvalue decomposition of a NON-SYMMETRIC matrix: single precision complex, i.e.">utility_ceig()</a>  <a href="structutility__ceig__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__zeig__data.html">utility_zeig_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga90fb063ed9e27f39f066f66e6f6f09d0" title="Eigenvalue decomposition of a NON-SYMMETRIC matrix: double precision complex, i.e.">utility_zeig()</a>  <a href="structutility__zeig__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__sglslv__data.html">utility_sglslv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga640280189eb46372f1eebb1f2316b66d" title="General linear solver: single precision, i.e.">utility_sglslv()</a>  <a href="structutility__sglslv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__cglslv__data.html">utility_cglslv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga1a6952cd39e4eb6b2ee4c6ccc9235efa" title="General linear solver: single precision complex, i.e.">utility_cglslv()</a>  <a href="structutility__cglslv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__dglslv__data.html">utility_dglslv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga3818ad01572db6ef6e8ca2fae09abfd1" title="General linear solver: double precision, i.e.">utility_dglslv()</a>  <a href="structutility__dglslv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__zglslv__data.html">utility_zglslv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga62b0d514709f3f6d5f3ecf14aada7d0d" title="General linear solver: double precision complex, i.e.">utility_zglslv()</a>  <a href="structutility__zglslv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__sglslvt__data.html">utility_sglslvt_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga4badbca16fc3eb548a0e9dbc6656549b" title="General linear solver (the other way): single precision, i.e.">utility_sglslvt()</a>  <a href="structutility__sglslvt__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__sslslv__data.html">utility_sslslv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#gacbc24ee7716fdbe5464d1498a5e2e9e9" title="Linear solver for SYMMETRIC positive-definate &#39;A&#39;: single precision, i.e.">utility_sslslv()</a>  <a href="structutility__sslslv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__cslslv__data.html">utility_cslslv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#gafefb569a834b48faa9117896e9cd95fb" title="Linear solver for HERMITIAN positive-definate &#39;A&#39;: single precision complex, i.e.">utility_cslslv()</a>  <a href="structutility__cslslv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__spinv__data.html">utility_spinv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga6f705e59e9e93b989f11c5f2cfbca343" title="General matrix pseudo-inverse (the svd way): single precision, i.e.">utility_spinv()</a>  <a href="structutility__spinv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__cpinv__data.html">utility_cpinv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga75a5928c5eb152542620b6f3ae327e23" title="General matrix pseudo-inverse (the svd way): single precision complex, i.e.">utility_cpinv()</a>  <a href="structutility__cpinv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__dpinv__data.html">utility_dpinv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga880fd9f2a7af6977f60be5106ab6e28c" title="General matrix pseudo-inverse (the svd way): double precision, i.e.">utility_dpinv()</a>  <a href="structutility__dpinv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__zpinv__data.html">utility_zpinv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#gaa0a13680d6de48e6ad3f05068b4673e5" title="General matrix pseudo-inverse (the svd way): double precision complex, i.e.">utility_zpinv()</a>  <a href="structutility__zpinv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__schol__data.html">utility_schol_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga8e0b45ee898c3f34d510f98a6a1fabab" title="Cholesky factorisation of a symmetric matrix positive-definate matrix: single precision,...">utility_schol()</a>  <a href="structutility__schol__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__cchol__data.html">utility_cchol_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#gaabda3952e00d301d103bc3425cae3303" title="Cholesky factorisation of a hermitian positive-definate matrix: single precision complex,...">utility_cchol()</a>  <a href="structutility__cchol__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__sdet__data.html">utility_sdet_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#gabbed89fdf056f2118a8049aa5a4ef8c6" title="Determinant of a Matrix, single precision, i,e.">utility_sdet()</a>  <a href="structutility__sdet__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__ddet__data.html">utility_ddet_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga0973535862b0f4ec7ba68810bb65ddcf" title="Determinant of a Matrix, double precision, i,e.">utility_ddet()</a>  <a href="structutility__ddet__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__sinv__data.html">utility_sinv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga7ded692ae35912f07fda80681f302fd6" title="Matrix inversion: single precision, i.e.">utility_sinv()</a>  <a href="structutility__sinv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__dinv__data.html">utility_dinv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga06952e48c6f327c4b84363b872549fe7" title="Matrix inversion: double precision, i.e.">utility_dinv()</a>  <a href="structutility__dinv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutility__cinv__data.html">utility_cinv_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for <a class="el" href="group___utilities.html#ga206dec6445519c3d2e3a72d760442a93" title="Matrix inversion: double precision complex, i.e.">utility_cinv()</a>  <a href="structutility__cinv__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a62af0907d66bd565ec7a82efc8217ce5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__utility__veclib_8c.html#a62af0907d66bd565ec7a82efc8217ce5">SAF_VECLIB_USE_LAPACK_FORTRAN_INTERFACE</a></td></tr>
<tr class="memdesc:a62af0907d66bd565ec7a82efc8217ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LAPACK interface.  <br /></td></tr>
<tr class="separator:a62af0907d66bd565ec7a82efc8217ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85d0063826ded1109fbe6b6e029348e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__utility__veclib_8c.html#aa85d0063826ded1109fbe6b6e029348e">SAF_INTEL_MKL_VML_MODE</a>&#160;&#160;&#160;( VML_LA | VML_FTZDAZ_ON )</td></tr>
<tr class="memdesc:aa85d0063826ded1109fbe6b6e029348e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Taken from the Intel MKL VML developers reference documentation: The flag(s) that can be passed to Intel VML functions:  <br /></td></tr>
<tr class="separator:aa85d0063826ded1109fbe6b6e029348e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8a1892647cd90c5d7d67575fcfd149fa"><td class="memItemLeft" align="right" valign="top">typedef MKL_INT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__utility__veclib_8c.html#a8a1892647cd90c5d7d67575fcfd149fa">veclib_int</a></td></tr>
<tr class="memdesc:a8a1892647cd90c5d7d67575fcfd149fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer: 4-bytes  <br /></td></tr>
<tr class="separator:a8a1892647cd90c5d7d67575fcfd149fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4916c87c8ec713c92d69bfaebef60b1"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__utility__veclib_8c.html#ad4916c87c8ec713c92d69bfaebef60b1">veclib_float</a></td></tr>
<tr class="memdesc:ad4916c87c8ec713c92d69bfaebef60b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">real: 4-bytes  <br /></td></tr>
<tr class="separator:ad4916c87c8ec713c92d69bfaebef60b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276629847a41b280b9d23b05b0a161e9"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__utility__veclib_8c.html#a276629847a41b280b9d23b05b0a161e9">veclib_double</a></td></tr>
<tr class="memdesc:a276629847a41b280b9d23b05b0a161e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">real: 8-bytes  <br /></td></tr>
<tr class="separator:a276629847a41b280b9d23b05b0a161e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a92f56e80caec41cbe4a2002549b1f"><td class="memItemLeft" align="right" valign="top">typedef MKL_Complex8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__utility__veclib_8c.html#a96a92f56e80caec41cbe4a2002549b1f">veclib_float_complex</a></td></tr>
<tr class="memdesc:a96a92f56e80caec41cbe4a2002549b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex: 8-bytes  <br /></td></tr>
<tr class="separator:a96a92f56e80caec41cbe4a2002549b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3637f07b00295a2e137f60a7afe0e4"><td class="memItemLeft" align="right" valign="top">typedef MKL_Complex16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__utility__veclib_8c.html#a8b3637f07b00295a2e137f60a7afe0e4">veclib_double_complex</a></td></tr>
<tr class="memdesc:a8b3637f07b00295a2e137f60a7afe0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex: 16-bytes  <br /></td></tr>
<tr class="separator:a8b3637f07b00295a2e137f60a7afe0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf34cdd4172744886a0ed8d5c938ed93b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaf34cdd4172744886a0ed8d5c938ed93b">utility_siminv</a> (const float *a, const int len, int *index)</td></tr>
<tr class="memdesc:gaf34cdd4172744886a0ed8d5c938ed93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, index of minimum absolute value in a vector, i.e.  <br /></td></tr>
<tr class="separator:gaf34cdd4172744886a0ed8d5c938ed93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f536159d4f1c1ecd05a8f13f10a2d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga47f536159d4f1c1ecd05a8f13f10a2d5">utility_ciminv</a> (const float_complex *a, const int len, int *index)</td></tr>
<tr class="memdesc:ga47f536159d4f1c1ecd05a8f13f10a2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, index of maximum absolute value in a vector, i.e.  <br /></td></tr>
<tr class="separator:ga47f536159d4f1c1ecd05a8f13f10a2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae160778b599a27fe389084c080f077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga8ae160778b599a27fe389084c080f077">utility_diminv</a> (const double *a, const int len, int *index)</td></tr>
<tr class="memdesc:ga8ae160778b599a27fe389084c080f077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, index of minimum absolute value in a vector, i.e.  <br /></td></tr>
<tr class="separator:ga8ae160778b599a27fe389084c080f077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ba81ead144d6909ec8125afe91e91f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga27ba81ead144d6909ec8125afe91e91f">utility_ziminv</a> (const double_complex *a, const int len, int *index)</td></tr>
<tr class="memdesc:ga27ba81ead144d6909ec8125afe91e91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, complex, index of maximum absolute value in a vector, i.e.  <br /></td></tr>
<tr class="separator:ga27ba81ead144d6909ec8125afe91e91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf733d65eaed0015c6ba428a07eda867a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaf733d65eaed0015c6ba428a07eda867a">utility_simaxv</a> (const float *a, const int len, int *index)</td></tr>
<tr class="memdesc:gaf733d65eaed0015c6ba428a07eda867a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, index of maximum absolute value in a vector, i.e.  <br /></td></tr>
<tr class="separator:gaf733d65eaed0015c6ba428a07eda867a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6600bec30da8cb52c95697fc81ded614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga6600bec30da8cb52c95697fc81ded614">utility_cimaxv</a> (const float_complex *a, const int len, int *index)</td></tr>
<tr class="memdesc:ga6600bec30da8cb52c95697fc81ded614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, index of maximum absolute value in a vector, i.e.  <br /></td></tr>
<tr class="separator:ga6600bec30da8cb52c95697fc81ded614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga005909eceb2e45f59890ced458300433"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga005909eceb2e45f59890ced458300433">utility_dimaxv</a> (const double *a, const int len, int *index)</td></tr>
<tr class="memdesc:ga005909eceb2e45f59890ced458300433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, index of maximum absolute value in a vector, i.e.  <br /></td></tr>
<tr class="separator:ga005909eceb2e45f59890ced458300433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d81ec7663bbc27601aa31ab44d99d49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga4d81ec7663bbc27601aa31ab44d99d49">utility_zimaxv</a> (const double_complex *a, const int len, int *index)</td></tr>
<tr class="memdesc:ga4d81ec7663bbc27601aa31ab44d99d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, complex, index of maximum absolute value in a vector, i.e.  <br /></td></tr>
<tr class="separator:ga4d81ec7663bbc27601aa31ab44d99d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaaae918746a4c589ea33cc62ea079fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaeaaae918746a4c589ea33cc62ea079fb">utility_svabs</a> (const float *a, const int len, float *c)</td></tr>
<tr class="memdesc:gaeaaae918746a4c589ea33cc62ea079fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, absolute values of vector elements, i.e.  <br /></td></tr>
<tr class="separator:gaeaaae918746a4c589ea33cc62ea079fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga911b4a7ea87c93e71e870c27b5ae32ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga911b4a7ea87c93e71e870c27b5ae32ba">utility_cvabs</a> (const float_complex *a, const int len, float *c)</td></tr>
<tr class="memdesc:ga911b4a7ea87c93e71e870c27b5ae32ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, absolute values of vector elements, i.e.  <br /></td></tr>
<tr class="separator:ga911b4a7ea87c93e71e870c27b5ae32ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2669d4d0854839ec3a16ff4243a6d630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga2669d4d0854839ec3a16ff4243a6d630">utility_svmod</a> (const float *a, const float *b, const int len, float *c)</td></tr>
<tr class="memdesc:ga2669d4d0854839ec3a16ff4243a6d630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, modulus of vector elements, i.e.  <br /></td></tr>
<tr class="separator:ga2669d4d0854839ec3a16ff4243a6d630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7569400349573257490c8ba6a95e52b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gac7569400349573257490c8ba6a95e52b">utility_svrecip</a> (const float *a, const int len, float *c)</td></tr>
<tr class="memdesc:gac7569400349573257490c8ba6a95e52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, vector-reciprocal/inversion, i.e.  <br /></td></tr>
<tr class="separator:gac7569400349573257490c8ba6a95e52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6946a0c603befdb7731417e422302a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gae6946a0c603befdb7731417e422302a0">utility_cvconj</a> (const float_complex *a, const int len, float_complex *c)</td></tr>
<tr class="memdesc:gae6946a0c603befdb7731417e422302a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, vector-conjugate, i.e.  <br /></td></tr>
<tr class="separator:gae6946a0c603befdb7731417e422302a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb49aab2ade37caf9d9dd32e29b4ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaeeb49aab2ade37caf9d9dd32e29b4ded">utility_zvconj</a> (const double_complex *a, const int len, double_complex *c)</td></tr>
<tr class="memdesc:gaeeb49aab2ade37caf9d9dd32e29b4ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, complex, vector-conjugate, i.e.  <br /></td></tr>
<tr class="separator:gaeeb49aab2ade37caf9d9dd32e29b4ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64608bbabb1b7bfd135fbb982a4d1e2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga64608bbabb1b7bfd135fbb982a4d1e2c">utility_svvcopy</a> (const float *a, const int len, float *c)</td></tr>
<tr class="memdesc:ga64608bbabb1b7bfd135fbb982a4d1e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, vector-vector copy, i.e.  <br /></td></tr>
<tr class="separator:ga64608bbabb1b7bfd135fbb982a4d1e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac335cac027bcb24d435f9a525587d9d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gac335cac027bcb24d435f9a525587d9d4">utility_cvvcopy</a> (const float_complex *a, const int len, float_complex *c)</td></tr>
<tr class="memdesc:gac335cac027bcb24d435f9a525587d9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, vector-vector copy, i.e.  <br /></td></tr>
<tr class="separator:gac335cac027bcb24d435f9a525587d9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9989d83bb58ff2690f2020f555c395e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gae9989d83bb58ff2690f2020f555c395e">utility_dvvcopy</a> (const double *a, const int len, double *c)</td></tr>
<tr class="memdesc:gae9989d83bb58ff2690f2020f555c395e"><td class="mdescLeft">&#160;</td><td class="mdescRight">double-precision, vector-vector copy, i.e.  <br /></td></tr>
<tr class="separator:gae9989d83bb58ff2690f2020f555c395e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c6ed6cdc165b5b8e51ca2aa207cfd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gab3c6ed6cdc165b5b8e51ca2aa207cfd4">utility_zvvcopy</a> (const double_complex *a, const int len, double_complex *c)</td></tr>
<tr class="memdesc:gab3c6ed6cdc165b5b8e51ca2aa207cfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">double-precision, complex, vector-vector copy, i.e.  <br /></td></tr>
<tr class="separator:gab3c6ed6cdc165b5b8e51ca2aa207cfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a1d2c387ca1752e99c8aee6d7d88f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gac4a1d2c387ca1752e99c8aee6d7d88f9">utility_svvadd</a> (const float *a, const float *b, const int len, float *c)</td></tr>
<tr class="memdesc:gac4a1d2c387ca1752e99c8aee6d7d88f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, vector-vector addition, i.e.  <br /></td></tr>
<tr class="separator:gac4a1d2c387ca1752e99c8aee6d7d88f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2e65b9e66140dbd34ae43aff9a3401"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga5c2e65b9e66140dbd34ae43aff9a3401">utility_cvvadd</a> (const float_complex *a, const float_complex *b, const int len, float_complex *c)</td></tr>
<tr class="memdesc:ga5c2e65b9e66140dbd34ae43aff9a3401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, vector-vector addition, i.e.  <br /></td></tr>
<tr class="separator:ga5c2e65b9e66140dbd34ae43aff9a3401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488c31e57d84d9ec96d067109e7af942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga488c31e57d84d9ec96d067109e7af942">utility_dvvadd</a> (const double *a, const double *b, const int len, double *c)</td></tr>
<tr class="memdesc:ga488c31e57d84d9ec96d067109e7af942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, vector-vector addition, i.e.  <br /></td></tr>
<tr class="separator:ga488c31e57d84d9ec96d067109e7af942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac15c6f1e7fa3f6d7036b393c7d1ba2cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gac15c6f1e7fa3f6d7036b393c7d1ba2cc">utility_zvvadd</a> (const double_complex *a, const double_complex *b, const int len, double_complex *c)</td></tr>
<tr class="memdesc:gac15c6f1e7fa3f6d7036b393c7d1ba2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, complex, vector-vector addition, i.e.  <br /></td></tr>
<tr class="separator:gac15c6f1e7fa3f6d7036b393c7d1ba2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga498a27b0fb1d2e0571b822c14d2f5cb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga498a27b0fb1d2e0571b822c14d2f5cb5">utility_svvsub</a> (const float *a, const float *b, const int len, float *c)</td></tr>
<tr class="memdesc:ga498a27b0fb1d2e0571b822c14d2f5cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, vector-vector subtraction, i.e.  <br /></td></tr>
<tr class="separator:ga498a27b0fb1d2e0571b822c14d2f5cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e7559d0b5ea7c37e1fa694cb975abae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga9e7559d0b5ea7c37e1fa694cb975abae">utility_cvvsub</a> (const float_complex *a, const float_complex *b, const int len, float_complex *c)</td></tr>
<tr class="memdesc:ga9e7559d0b5ea7c37e1fa694cb975abae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, vector-vector subtraction, i.e.  <br /></td></tr>
<tr class="separator:ga9e7559d0b5ea7c37e1fa694cb975abae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28da7fa285f57c38aaf2bd810f5f6c4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga28da7fa285f57c38aaf2bd810f5f6c4d">utility_dvvsub</a> (const double *a, const double *b, const int len, double *c)</td></tr>
<tr class="memdesc:ga28da7fa285f57c38aaf2bd810f5f6c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, vector-vector subtraction, i.e.  <br /></td></tr>
<tr class="separator:ga28da7fa285f57c38aaf2bd810f5f6c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba7b2131ec67e32bec6dfb3b2596c07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga0ba7b2131ec67e32bec6dfb3b2596c07">utility_zvvsub</a> (const double_complex *a, const double_complex *b, const int len, double_complex *c)</td></tr>
<tr class="memdesc:ga0ba7b2131ec67e32bec6dfb3b2596c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, complex, vector-vector subtraction, i.e.  <br /></td></tr>
<tr class="separator:ga0ba7b2131ec67e32bec6dfb3b2596c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4904e43e873cdeaca89beb0363dd7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga1f4904e43e873cdeaca89beb0363dd7b">utility_svvmul</a> (const float *a, const float *b, const int len, float *c)</td></tr>
<tr class="memdesc:ga1f4904e43e873cdeaca89beb0363dd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, element-wise vector-vector multiplication i.e.  <br /></td></tr>
<tr class="separator:ga1f4904e43e873cdeaca89beb0363dd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea6c6a40abe15f994e3ff03e595399c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga1ea6c6a40abe15f994e3ff03e595399c">utility_cvvmul</a> (const float_complex *a, const float_complex *b, const int len, float_complex *c)</td></tr>
<tr class="memdesc:ga1ea6c6a40abe15f994e3ff03e595399c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, element-wise vector-vector multiplication i.e.  <br /></td></tr>
<tr class="separator:ga1ea6c6a40abe15f994e3ff03e595399c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae190ef14372ec0af61a4ac2da3b2c77d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gae190ef14372ec0af61a4ac2da3b2c77d">utility_svvdot</a> (const float *a, const float *b, const int len, float *c)</td></tr>
<tr class="memdesc:gae190ef14372ec0af61a4ac2da3b2c77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, vector-vector dot product, i.e.  <br /></td></tr>
<tr class="separator:gae190ef14372ec0af61a4ac2da3b2c77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9172e1212262a626b93912ff375ad3d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga9172e1212262a626b93912ff375ad3d8">utility_cvvdot</a> (const float_complex *a, const float_complex *b, const int len, <a class="el" href="group___utilities.html#ga64250558cc5507fb5ec6515ab4d337ce">CONJ_FLAG</a> flag, float_complex *c)</td></tr>
<tr class="memdesc:ga9172e1212262a626b93912ff375ad3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, vector-vector dot product, i.e.  <br /></td></tr>
<tr class="separator:ga9172e1212262a626b93912ff375ad3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed09df6b262daceb834b98dd9eeb202c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaed09df6b262daceb834b98dd9eeb202c">utility_svsmul</a> (float *a, const float *s, const int len, float *c)</td></tr>
<tr class="memdesc:gaed09df6b262daceb834b98dd9eeb202c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, multiplies each element in vector 'a' with a scalar 's', i.e.  <br /></td></tr>
<tr class="separator:gaed09df6b262daceb834b98dd9eeb202c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4044ddbce451c1d2d1d8afb51201c1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gad4044ddbce451c1d2d1d8afb51201c1d">utility_cvsmul</a> (float_complex *a, const float_complex *s, const int len, float_complex *c)</td></tr>
<tr class="memdesc:gad4044ddbce451c1d2d1d8afb51201c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, multiplies each element in vector 'a' with a scalar 's', i.e.  <br /></td></tr>
<tr class="separator:gad4044ddbce451c1d2d1d8afb51201c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga221dd1921c5ddca5795739faa594dc6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga221dd1921c5ddca5795739faa594dc6f">utility_dvsmul</a> (double *a, const double *s, const int len, double *c)</td></tr>
<tr class="memdesc:ga221dd1921c5ddca5795739faa594dc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, multiplies each element in vector 'a' with a scalar 's', i.e.  <br /></td></tr>
<tr class="separator:ga221dd1921c5ddca5795739faa594dc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3890ab0bc579a6ee65345118f4598a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga3890ab0bc579a6ee65345118f4598a3c">utility_zvsmul</a> (double_complex *a, const double_complex *s, const int len, double_complex *c)</td></tr>
<tr class="memdesc:ga3890ab0bc579a6ee65345118f4598a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision, complex, multiplies each element in vector 'a' with a scalar 's', i.e.  <br /></td></tr>
<tr class="separator:ga3890ab0bc579a6ee65345118f4598a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b3086bc470b3068ab73f33248c5818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gae5b3086bc470b3068ab73f33248c5818">utility_svsdiv</a> (const float *a, const float *s, const int len, float *c)</td></tr>
<tr class="memdesc:gae5b3086bc470b3068ab73f33248c5818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, divides each element in vector 'a' with a scalar 's', i.e.  <br /></td></tr>
<tr class="separator:gae5b3086bc470b3068ab73f33248c5818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46848011ca30d85e0a4a6a3015b3cf30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga46848011ca30d85e0a4a6a3015b3cf30">utility_svsadd</a> (float *a, const float *s, const int len, float *c)</td></tr>
<tr class="memdesc:ga46848011ca30d85e0a4a6a3015b3cf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, adds each element in vector 'a' with a scalar 's', i.e.  <br /></td></tr>
<tr class="separator:ga46848011ca30d85e0a4a6a3015b3cf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48aca79eea1ca15a66e1e9a42e75f872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga48aca79eea1ca15a66e1e9a42e75f872">utility_svssub</a> (float *a, const float *s, const int len, float *c)</td></tr>
<tr class="memdesc:ga48aca79eea1ca15a66e1e9a42e75f872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, subtracts each element in vector 'a' with a scalar 's', i.e.  <br /></td></tr>
<tr class="separator:ga48aca79eea1ca15a66e1e9a42e75f872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f8e3a56ee1020d0befdc42ad200f27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaf6f8e3a56ee1020d0befdc42ad200f27">utility_ssv2cv_inds</a> (const float *sv, const int *inds, const int len, float *cv)</td></tr>
<tr class="memdesc:gaf6f8e3a56ee1020d0befdc42ad200f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, sparse-vector to compressed vector given known indices i.e.  <br /></td></tr>
<tr class="separator:gaf6f8e3a56ee1020d0befdc42ad200f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a0abfefbf4e94e2ddac2d7c2107906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga49a0abfefbf4e94e2ddac2d7c2107906">utility_ssvd_create</a> (void **const phWork, int maxDim1, int maxDim2)</td></tr>
<tr class="memdesc:ga49a0abfefbf4e94e2ddac2d7c2107906"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga4bc9fb7cc785506dc196d48c04ded6ea" title="Singular value decomposition: single precision, i.e.">utility_ssvd()</a>  <br /></td></tr>
<tr class="separator:ga49a0abfefbf4e94e2ddac2d7c2107906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb6db7a21fdb895d68fcefe41661b09c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gafb6db7a21fdb895d68fcefe41661b09c">utility_ssvd_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gafb6db7a21fdb895d68fcefe41661b09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga4bc9fb7cc785506dc196d48c04ded6ea" title="Singular value decomposition: single precision, i.e.">utility_ssvd()</a>  <br /></td></tr>
<tr class="separator:gafb6db7a21fdb895d68fcefe41661b09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc9fb7cc785506dc196d48c04ded6ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga4bc9fb7cc785506dc196d48c04ded6ea">utility_ssvd</a> (void *const hWork, const float *A, const int dim1, const int dim2, float *U, float *S, float *V, float *sing)</td></tr>
<tr class="memdesc:ga4bc9fb7cc785506dc196d48c04ded6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular value decomposition: single precision, i.e.  <br /></td></tr>
<tr class="separator:ga4bc9fb7cc785506dc196d48c04ded6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac28763fdf9df4111716f94873445902b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gac28763fdf9df4111716f94873445902b">utility_csvd_create</a> (void **const phWork, int maxDim1, int maxDim2)</td></tr>
<tr class="memdesc:gac28763fdf9df4111716f94873445902b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga87c408fda14dfb4e3cf83ac29fe25b6b" title="Singular value decomposition: single precision complex, i.e.">utility_csvd()</a>  <br /></td></tr>
<tr class="separator:gac28763fdf9df4111716f94873445902b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c10002c5a4854de38f4c8d268ab18b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga2c10002c5a4854de38f4c8d268ab18b6">utility_csvd_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga2c10002c5a4854de38f4c8d268ab18b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga87c408fda14dfb4e3cf83ac29fe25b6b" title="Singular value decomposition: single precision complex, i.e.">utility_csvd()</a>  <br /></td></tr>
<tr class="separator:ga2c10002c5a4854de38f4c8d268ab18b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c408fda14dfb4e3cf83ac29fe25b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga87c408fda14dfb4e3cf83ac29fe25b6b">utility_csvd</a> (void *const hWork, const float_complex *A, const int dim1, const int dim2, float_complex *U, float_complex *S, float_complex *V, float *sing)</td></tr>
<tr class="memdesc:ga87c408fda14dfb4e3cf83ac29fe25b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular value decomposition: single precision complex, i.e.  <br /></td></tr>
<tr class="separator:ga87c408fda14dfb4e3cf83ac29fe25b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a48de371c6366aef8042417126c3553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga7a48de371c6366aef8042417126c3553">utility_sseig_create</a> (void **const phWork, int maxDim)</td></tr>
<tr class="memdesc:ga7a48de371c6366aef8042417126c3553"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#gaa8246221927b40b174603801e00acf6c" title="Eigenvalue decomposition of a SYMMETRIC matrix: single precision, i.e.">utility_sseig()</a>  <br /></td></tr>
<tr class="separator:ga7a48de371c6366aef8042417126c3553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea215ae52d479cbb8de0ea420df40c32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaea215ae52d479cbb8de0ea420df40c32">utility_sseig_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gaea215ae52d479cbb8de0ea420df40c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#gaa8246221927b40b174603801e00acf6c" title="Eigenvalue decomposition of a SYMMETRIC matrix: single precision, i.e.">utility_sseig()</a>  <br /></td></tr>
<tr class="separator:gaea215ae52d479cbb8de0ea420df40c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8246221927b40b174603801e00acf6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaa8246221927b40b174603801e00acf6c">utility_sseig</a> (void *const hWork, const float *A, const int dim, int sortDecFLAG, float *V, float *D, float *eig)</td></tr>
<tr class="memdesc:gaa8246221927b40b174603801e00acf6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue decomposition of a SYMMETRIC matrix: single precision, i.e.  <br /></td></tr>
<tr class="separator:gaa8246221927b40b174603801e00acf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ac31daf60934140a89feec36a30c56f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga8ac31daf60934140a89feec36a30c56f">utility_cseig_create</a> (void **const phWork, int maxDim)</td></tr>
<tr class="memdesc:ga8ac31daf60934140a89feec36a30c56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga8641e94f44ce883e136db7315e8dccb3" title="Eigenvalue decomposition of a SYMMETRIC/HERMITION matrix: single precision complex,...">utility_cseig()</a>  <br /></td></tr>
<tr class="separator:ga8ac31daf60934140a89feec36a30c56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ff25c419ff3859099ef4a7a9ef7247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga46ff25c419ff3859099ef4a7a9ef7247">utility_cseig_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga46ff25c419ff3859099ef4a7a9ef7247"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga8641e94f44ce883e136db7315e8dccb3" title="Eigenvalue decomposition of a SYMMETRIC/HERMITION matrix: single precision complex,...">utility_cseig()</a>  <br /></td></tr>
<tr class="separator:ga46ff25c419ff3859099ef4a7a9ef7247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8641e94f44ce883e136db7315e8dccb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga8641e94f44ce883e136db7315e8dccb3">utility_cseig</a> (void *const hWork, const float_complex *A, const int dim, int sortDecFLAG, float_complex *V, float_complex *D, float *eig)</td></tr>
<tr class="memdesc:ga8641e94f44ce883e136db7315e8dccb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue decomposition of a SYMMETRIC/HERMITION matrix: single precision complex, i.e.  <br /></td></tr>
<tr class="separator:ga8641e94f44ce883e136db7315e8dccb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e685422172a370b54d505759af201a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga32e685422172a370b54d505759af201a">utility_ceigmp_create</a> (void **const phWork, int maxDim)</td></tr>
<tr class="memdesc:ga32e685422172a370b54d505759af201a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga0c0617eefc40f9dfe46a5d76c9a39b6d" title="Computes eigenvalues of a matrix pair using the QZ method, single precision complex,...">utility_ceigmp()</a>  <br /></td></tr>
<tr class="separator:ga32e685422172a370b54d505759af201a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c2498d47627d0c02cde6340b7593dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gac1c2498d47627d0c02cde6340b7593dd">utility_ceigmp_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gac1c2498d47627d0c02cde6340b7593dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga0c0617eefc40f9dfe46a5d76c9a39b6d" title="Computes eigenvalues of a matrix pair using the QZ method, single precision complex,...">utility_ceigmp()</a>  <br /></td></tr>
<tr class="separator:gac1c2498d47627d0c02cde6340b7593dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c0617eefc40f9dfe46a5d76c9a39b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga0c0617eefc40f9dfe46a5d76c9a39b6d">utility_ceigmp</a> (void *const hWork, const float_complex *A, const float_complex *B, const int dim, float_complex *VL, float_complex *VR, float_complex *D)</td></tr>
<tr class="memdesc:ga0c0617eefc40f9dfe46a5d76c9a39b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes eigenvalues of a matrix pair using the QZ method, single precision complex, i.e.  <br /></td></tr>
<tr class="separator:ga0c0617eefc40f9dfe46a5d76c9a39b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf61de88e2340d8dee9f14832d0006146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaf61de88e2340d8dee9f14832d0006146">utility_zeigmp_create</a> (void **const phWork, int maxDim)</td></tr>
<tr class="memdesc:gaf61de88e2340d8dee9f14832d0006146"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga56a643599c5f23e6e04a0d59306bbbc3" title="Computes eigenvalues of a matrix pair using the QZ method, double precision complex,...">utility_zeigmp()</a>  <br /></td></tr>
<tr class="separator:gaf61de88e2340d8dee9f14832d0006146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe97cbd8c1ddde6a486b4dc3077c1a3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gabe97cbd8c1ddde6a486b4dc3077c1a3f">utility_zeigmp_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gabe97cbd8c1ddde6a486b4dc3077c1a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga56a643599c5f23e6e04a0d59306bbbc3" title="Computes eigenvalues of a matrix pair using the QZ method, double precision complex,...">utility_zeigmp()</a>  <br /></td></tr>
<tr class="separator:gabe97cbd8c1ddde6a486b4dc3077c1a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a643599c5f23e6e04a0d59306bbbc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga56a643599c5f23e6e04a0d59306bbbc3">utility_zeigmp</a> (void *const hWork, const double_complex *A, const double_complex *B, const int dim, double_complex *VL, double_complex *VR, double_complex *D)</td></tr>
<tr class="memdesc:ga56a643599c5f23e6e04a0d59306bbbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes eigenvalues of a matrix pair using the QZ method, double precision complex, i.e.  <br /></td></tr>
<tr class="separator:ga56a643599c5f23e6e04a0d59306bbbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfde76a18f8ed9ae678fdf8cb8a831f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gadfde76a18f8ed9ae678fdf8cb8a831f3">utility_ceig_create</a> (void **const phWork, int maxDim)</td></tr>
<tr class="memdesc:gadfde76a18f8ed9ae678fdf8cb8a831f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga5baae978beb557f6642f3fcd78caa1dd" title="Eigenvalue decomposition of a NON-SYMMETRIC matrix: single precision complex, i.e.">utility_ceig()</a>  <br /></td></tr>
<tr class="separator:gadfde76a18f8ed9ae678fdf8cb8a831f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff81a784fe4771845ff9906c0ff96c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga1ff81a784fe4771845ff9906c0ff96c0">utility_ceig_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga1ff81a784fe4771845ff9906c0ff96c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga5baae978beb557f6642f3fcd78caa1dd" title="Eigenvalue decomposition of a NON-SYMMETRIC matrix: single precision complex, i.e.">utility_ceig()</a>  <br /></td></tr>
<tr class="separator:ga1ff81a784fe4771845ff9906c0ff96c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5baae978beb557f6642f3fcd78caa1dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga5baae978beb557f6642f3fcd78caa1dd">utility_ceig</a> (void *const hWork, const float_complex *A, const int dim, float_complex *VL, float_complex *VR, float_complex *D, float_complex *eig)</td></tr>
<tr class="memdesc:ga5baae978beb557f6642f3fcd78caa1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue decomposition of a NON-SYMMETRIC matrix: single precision complex, i.e.  <br /></td></tr>
<tr class="separator:ga5baae978beb557f6642f3fcd78caa1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44bd7694702b15b5beb364c9365b8c36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga44bd7694702b15b5beb364c9365b8c36">utility_zeig_create</a> (void **const phWork, int maxDim)</td></tr>
<tr class="memdesc:ga44bd7694702b15b5beb364c9365b8c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga90fb063ed9e27f39f066f66e6f6f09d0" title="Eigenvalue decomposition of a NON-SYMMETRIC matrix: double precision complex, i.e.">utility_zeig()</a>  <br /></td></tr>
<tr class="separator:ga44bd7694702b15b5beb364c9365b8c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d3e117d8645f13d13a98fac75db0ba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga1d3e117d8645f13d13a98fac75db0ba2">utility_zeig_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga1d3e117d8645f13d13a98fac75db0ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga90fb063ed9e27f39f066f66e6f6f09d0" title="Eigenvalue decomposition of a NON-SYMMETRIC matrix: double precision complex, i.e.">utility_zeig()</a>  <br /></td></tr>
<tr class="separator:ga1d3e117d8645f13d13a98fac75db0ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fb063ed9e27f39f066f66e6f6f09d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga90fb063ed9e27f39f066f66e6f6f09d0">utility_zeig</a> (void *const hWork, const double_complex *A, const int dim, double_complex *VL, double_complex *VR, double_complex *D, double_complex *eig)</td></tr>
<tr class="memdesc:ga90fb063ed9e27f39f066f66e6f6f09d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue decomposition of a NON-SYMMETRIC matrix: double precision complex, i.e.  <br /></td></tr>
<tr class="separator:ga90fb063ed9e27f39f066f66e6f6f09d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9617efb5795b0122dd2be667c18426b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga9617efb5795b0122dd2be667c18426b5">utility_sglslv_create</a> (void **const phWork, int maxDim, int maxNCol)</td></tr>
<tr class="memdesc:ga9617efb5795b0122dd2be667c18426b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga640280189eb46372f1eebb1f2316b66d" title="General linear solver: single precision, i.e.">utility_sglslv()</a>  <br /></td></tr>
<tr class="separator:ga9617efb5795b0122dd2be667c18426b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf728d162975420ca0a866c10ff423d08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaf728d162975420ca0a866c10ff423d08">utility_sglslv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gaf728d162975420ca0a866c10ff423d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga640280189eb46372f1eebb1f2316b66d" title="General linear solver: single precision, i.e.">utility_sglslv()</a>  <br /></td></tr>
<tr class="separator:gaf728d162975420ca0a866c10ff423d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga640280189eb46372f1eebb1f2316b66d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga640280189eb46372f1eebb1f2316b66d">utility_sglslv</a> (void *const hWork, const float *A, const int dim, float *B, int nCol, float *X)</td></tr>
<tr class="memdesc:ga640280189eb46372f1eebb1f2316b66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">General linear solver: single precision, i.e.  <br /></td></tr>
<tr class="separator:ga640280189eb46372f1eebb1f2316b66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc87644e0dfa5bf1e8888c1190c1a8e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gadc87644e0dfa5bf1e8888c1190c1a8e6">utility_cglslv_create</a> (void **const phWork, int maxDim, int maxNCol)</td></tr>
<tr class="memdesc:gadc87644e0dfa5bf1e8888c1190c1a8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga1a6952cd39e4eb6b2ee4c6ccc9235efa" title="General linear solver: single precision complex, i.e.">utility_cglslv()</a>  <br /></td></tr>
<tr class="separator:gadc87644e0dfa5bf1e8888c1190c1a8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16551f5de5a31b9c4893571e8b9603a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga16551f5de5a31b9c4893571e8b9603a1">utility_cglslv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga16551f5de5a31b9c4893571e8b9603a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga1a6952cd39e4eb6b2ee4c6ccc9235efa" title="General linear solver: single precision complex, i.e.">utility_cglslv()</a>  <br /></td></tr>
<tr class="separator:ga16551f5de5a31b9c4893571e8b9603a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a6952cd39e4eb6b2ee4c6ccc9235efa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga1a6952cd39e4eb6b2ee4c6ccc9235efa">utility_cglslv</a> (void *const hWork, const float_complex *A, const int dim, float_complex *B, int nCol, float_complex *X)</td></tr>
<tr class="memdesc:ga1a6952cd39e4eb6b2ee4c6ccc9235efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">General linear solver: single precision complex, i.e.  <br /></td></tr>
<tr class="separator:ga1a6952cd39e4eb6b2ee4c6ccc9235efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae045b03ded09582c644444786b057588"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gae045b03ded09582c644444786b057588">utility_dglslv_create</a> (void **const phWork, int maxDim, int maxNCol)</td></tr>
<tr class="memdesc:gae045b03ded09582c644444786b057588"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga3818ad01572db6ef6e8ca2fae09abfd1" title="General linear solver: double precision, i.e.">utility_dglslv()</a>  <br /></td></tr>
<tr class="separator:gae045b03ded09582c644444786b057588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bfb07b52e6e36a831c6df0d53ff7fd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga3bfb07b52e6e36a831c6df0d53ff7fd4">utility_dglslv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga3bfb07b52e6e36a831c6df0d53ff7fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga3818ad01572db6ef6e8ca2fae09abfd1" title="General linear solver: double precision, i.e.">utility_dglslv()</a>  <br /></td></tr>
<tr class="separator:ga3bfb07b52e6e36a831c6df0d53ff7fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3818ad01572db6ef6e8ca2fae09abfd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga3818ad01572db6ef6e8ca2fae09abfd1">utility_dglslv</a> (void *const hWork, const double *A, const int dim, double *B, int nCol, double *X)</td></tr>
<tr class="memdesc:ga3818ad01572db6ef6e8ca2fae09abfd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">General linear solver: double precision, i.e.  <br /></td></tr>
<tr class="separator:ga3818ad01572db6ef6e8ca2fae09abfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae678980c7d96e958172034c535a4473c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gae678980c7d96e958172034c535a4473c">utility_zglslv_create</a> (void **const phWork, int maxDim, int maxNCol)</td></tr>
<tr class="memdesc:gae678980c7d96e958172034c535a4473c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga62b0d514709f3f6d5f3ecf14aada7d0d" title="General linear solver: double precision complex, i.e.">utility_zglslv()</a>  <br /></td></tr>
<tr class="separator:gae678980c7d96e958172034c535a4473c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f3803a31175dd00846bb882aaa7fff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga7f3803a31175dd00846bb882aaa7fff3">utility_zglslv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga7f3803a31175dd00846bb882aaa7fff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga62b0d514709f3f6d5f3ecf14aada7d0d" title="General linear solver: double precision complex, i.e.">utility_zglslv()</a>  <br /></td></tr>
<tr class="separator:ga7f3803a31175dd00846bb882aaa7fff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b0d514709f3f6d5f3ecf14aada7d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga62b0d514709f3f6d5f3ecf14aada7d0d">utility_zglslv</a> (void *const hWork, const double_complex *A, const int dim, double_complex *B, int nCol, double_complex *X)</td></tr>
<tr class="memdesc:ga62b0d514709f3f6d5f3ecf14aada7d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">General linear solver: double precision complex, i.e.  <br /></td></tr>
<tr class="separator:ga62b0d514709f3f6d5f3ecf14aada7d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b5e6522abcb5cc052322540f25056e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gac9b5e6522abcb5cc052322540f25056e">utility_sglslvt_create</a> (void **const phWork, int maxDim, int maxNCol)</td></tr>
<tr class="memdesc:gac9b5e6522abcb5cc052322540f25056e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga4badbca16fc3eb548a0e9dbc6656549b" title="General linear solver (the other way): single precision, i.e.">utility_sglslvt()</a>  <br /></td></tr>
<tr class="separator:gac9b5e6522abcb5cc052322540f25056e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c459b303a14ba055070cd40aef8e31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga85c459b303a14ba055070cd40aef8e31">utility_sglslvt_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga85c459b303a14ba055070cd40aef8e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga4badbca16fc3eb548a0e9dbc6656549b" title="General linear solver (the other way): single precision, i.e.">utility_sglslvt()</a>  <br /></td></tr>
<tr class="separator:ga85c459b303a14ba055070cd40aef8e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4badbca16fc3eb548a0e9dbc6656549b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga4badbca16fc3eb548a0e9dbc6656549b">utility_sglslvt</a> (void *const hWork, const float *A, const int dim, float *B, int nCol, float *X)</td></tr>
<tr class="memdesc:ga4badbca16fc3eb548a0e9dbc6656549b"><td class="mdescLeft">&#160;</td><td class="mdescRight">General linear solver (the other way): single precision, i.e.  <br /></td></tr>
<tr class="separator:ga4badbca16fc3eb548a0e9dbc6656549b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8045aa4b3d315f5c85d4abc59ae7b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gabf8045aa4b3d315f5c85d4abc59ae7b5">utility_sslslv_create</a> (void **const phWork, int maxDim, int maxNCol)</td></tr>
<tr class="memdesc:gabf8045aa4b3d315f5c85d4abc59ae7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#gacbc24ee7716fdbe5464d1498a5e2e9e9" title="Linear solver for SYMMETRIC positive-definate &#39;A&#39;: single precision, i.e.">utility_sslslv()</a>  <br /></td></tr>
<tr class="separator:gabf8045aa4b3d315f5c85d4abc59ae7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c3f9c7cea0c6c4c6e541b4ad9b8cbf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga8c3f9c7cea0c6c4c6e541b4ad9b8cbf1">utility_sslslv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga8c3f9c7cea0c6c4c6e541b4ad9b8cbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#gacbc24ee7716fdbe5464d1498a5e2e9e9" title="Linear solver for SYMMETRIC positive-definate &#39;A&#39;: single precision, i.e.">utility_sslslv()</a>  <br /></td></tr>
<tr class="separator:ga8c3f9c7cea0c6c4c6e541b4ad9b8cbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbc24ee7716fdbe5464d1498a5e2e9e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gacbc24ee7716fdbe5464d1498a5e2e9e9">utility_sslslv</a> (void *const hWork, const float *A, const int dim, float *B, int nCol, float *X)</td></tr>
<tr class="memdesc:gacbc24ee7716fdbe5464d1498a5e2e9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear solver for SYMMETRIC positive-definate 'A': single precision, i.e.  <br /></td></tr>
<tr class="separator:gacbc24ee7716fdbe5464d1498a5e2e9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774b98955e3d6784a3072477fbb1c004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga774b98955e3d6784a3072477fbb1c004">utility_cslslv_create</a> (void **const phWork, int maxDim, int maxNCol)</td></tr>
<tr class="memdesc:ga774b98955e3d6784a3072477fbb1c004"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#gafefb569a834b48faa9117896e9cd95fb" title="Linear solver for HERMITIAN positive-definate &#39;A&#39;: single precision complex, i.e.">utility_cslslv()</a>  <br /></td></tr>
<tr class="separator:ga774b98955e3d6784a3072477fbb1c004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae62c8758bc1e8acf0c918129df53b0a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gae62c8758bc1e8acf0c918129df53b0a6">utility_cslslv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gae62c8758bc1e8acf0c918129df53b0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#gafefb569a834b48faa9117896e9cd95fb" title="Linear solver for HERMITIAN positive-definate &#39;A&#39;: single precision complex, i.e.">utility_cslslv()</a>  <br /></td></tr>
<tr class="separator:gae62c8758bc1e8acf0c918129df53b0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafefb569a834b48faa9117896e9cd95fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gafefb569a834b48faa9117896e9cd95fb">utility_cslslv</a> (void *const hWork, const float_complex *A, const int dim, float_complex *B, int nCol, float_complex *X)</td></tr>
<tr class="memdesc:gafefb569a834b48faa9117896e9cd95fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear solver for HERMITIAN positive-definate 'A': single precision complex, i.e.  <br /></td></tr>
<tr class="separator:gafefb569a834b48faa9117896e9cd95fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02e7ca57e03f2ec6c1f5b8e655f109f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga02e7ca57e03f2ec6c1f5b8e655f109f8">utility_spinv_create</a> (void **const phWork, int maxDim1, int maxDim2)</td></tr>
<tr class="memdesc:ga02e7ca57e03f2ec6c1f5b8e655f109f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga6f705e59e9e93b989f11c5f2cfbca343" title="General matrix pseudo-inverse (the svd way): single precision, i.e.">utility_spinv()</a>  <br /></td></tr>
<tr class="separator:ga02e7ca57e03f2ec6c1f5b8e655f109f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca24eebc6de1736b5bc89ec86429fa6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaca24eebc6de1736b5bc89ec86429fa6d">utility_spinv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gaca24eebc6de1736b5bc89ec86429fa6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga6f705e59e9e93b989f11c5f2cfbca343" title="General matrix pseudo-inverse (the svd way): single precision, i.e.">utility_spinv()</a>  <br /></td></tr>
<tr class="separator:gaca24eebc6de1736b5bc89ec86429fa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f705e59e9e93b989f11c5f2cfbca343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga6f705e59e9e93b989f11c5f2cfbca343">utility_spinv</a> (void *const hWork, const float *inM, const int dim1, const int dim2, float *outM)</td></tr>
<tr class="memdesc:ga6f705e59e9e93b989f11c5f2cfbca343"><td class="mdescLeft">&#160;</td><td class="mdescRight">General matrix pseudo-inverse (the svd way): single precision, i.e.  <br /></td></tr>
<tr class="separator:ga6f705e59e9e93b989f11c5f2cfbca343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eea25946ca1ba51ef9ac08a1c39cad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga0eea25946ca1ba51ef9ac08a1c39cad6">utility_cpinv_create</a> (void **const phWork, int maxDim1, int maxDim2)</td></tr>
<tr class="memdesc:ga0eea25946ca1ba51ef9ac08a1c39cad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga75a5928c5eb152542620b6f3ae327e23" title="General matrix pseudo-inverse (the svd way): single precision complex, i.e.">utility_cpinv()</a>  <br /></td></tr>
<tr class="separator:ga0eea25946ca1ba51ef9ac08a1c39cad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847846e7c169995580914f9759b0307e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga847846e7c169995580914f9759b0307e">utility_cpinv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga847846e7c169995580914f9759b0307e"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga75a5928c5eb152542620b6f3ae327e23" title="General matrix pseudo-inverse (the svd way): single precision complex, i.e.">utility_cpinv()</a>  <br /></td></tr>
<tr class="separator:ga847846e7c169995580914f9759b0307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a5928c5eb152542620b6f3ae327e23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga75a5928c5eb152542620b6f3ae327e23">utility_cpinv</a> (void *const hWork, const float_complex *inM, const int dim1, const int dim2, float_complex *outM)</td></tr>
<tr class="memdesc:ga75a5928c5eb152542620b6f3ae327e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">General matrix pseudo-inverse (the svd way): single precision complex, i.e.  <br /></td></tr>
<tr class="separator:ga75a5928c5eb152542620b6f3ae327e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72c90c1b5727ba4318a05bf7cb588029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga72c90c1b5727ba4318a05bf7cb588029">utility_dpinv_create</a> (void **const phWork, int maxDim1, int maxDim2)</td></tr>
<tr class="memdesc:ga72c90c1b5727ba4318a05bf7cb588029"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga880fd9f2a7af6977f60be5106ab6e28c" title="General matrix pseudo-inverse (the svd way): double precision, i.e.">utility_dpinv()</a>  <br /></td></tr>
<tr class="separator:ga72c90c1b5727ba4318a05bf7cb588029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862cc3fd22276d0ba4bc1cbf59200af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga862cc3fd22276d0ba4bc1cbf59200af2">utility_dpinv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga862cc3fd22276d0ba4bc1cbf59200af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga880fd9f2a7af6977f60be5106ab6e28c" title="General matrix pseudo-inverse (the svd way): double precision, i.e.">utility_dpinv()</a>  <br /></td></tr>
<tr class="separator:ga862cc3fd22276d0ba4bc1cbf59200af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880fd9f2a7af6977f60be5106ab6e28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga880fd9f2a7af6977f60be5106ab6e28c">utility_dpinv</a> (void *const hWork, const double *inM, const int dim1, const int dim2, double *outM)</td></tr>
<tr class="memdesc:ga880fd9f2a7af6977f60be5106ab6e28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">General matrix pseudo-inverse (the svd way): double precision, i.e.  <br /></td></tr>
<tr class="separator:ga880fd9f2a7af6977f60be5106ab6e28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa66804c246b0c145352f415da52a4c1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaa66804c246b0c145352f415da52a4c1e">utility_zpinv_create</a> (void **const phWork, int maxDim1, int maxDim2)</td></tr>
<tr class="memdesc:gaa66804c246b0c145352f415da52a4c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#gaa0a13680d6de48e6ad3f05068b4673e5" title="General matrix pseudo-inverse (the svd way): double precision complex, i.e.">utility_zpinv()</a>  <br /></td></tr>
<tr class="separator:gaa66804c246b0c145352f415da52a4c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafceacfcf76fc84a88aae339a5915b678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gafceacfcf76fc84a88aae339a5915b678">utility_zpinv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gafceacfcf76fc84a88aae339a5915b678"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#gaa0a13680d6de48e6ad3f05068b4673e5" title="General matrix pseudo-inverse (the svd way): double precision complex, i.e.">utility_zpinv()</a>  <br /></td></tr>
<tr class="separator:gafceacfcf76fc84a88aae339a5915b678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a13680d6de48e6ad3f05068b4673e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaa0a13680d6de48e6ad3f05068b4673e5">utility_zpinv</a> (void *const hWork, const double_complex *inM, const int dim1, const int dim2, double_complex *outM)</td></tr>
<tr class="memdesc:gaa0a13680d6de48e6ad3f05068b4673e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">General matrix pseudo-inverse (the svd way): double precision complex, i.e.  <br /></td></tr>
<tr class="separator:gaa0a13680d6de48e6ad3f05068b4673e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0b9fe007c66f62a0230bc34b20bc4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gabf0b9fe007c66f62a0230bc34b20bc4e">utility_schol_create</a> (void **const phWork, int maxDim)</td></tr>
<tr class="memdesc:gabf0b9fe007c66f62a0230bc34b20bc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga8e0b45ee898c3f34d510f98a6a1fabab" title="Cholesky factorisation of a symmetric matrix positive-definate matrix: single precision,...">utility_schol()</a>  <br /></td></tr>
<tr class="separator:gabf0b9fe007c66f62a0230bc34b20bc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga417de323318b34b34595c4804ad6ee7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga417de323318b34b34595c4804ad6ee7b">utility_schol_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga417de323318b34b34595c4804ad6ee7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga8e0b45ee898c3f34d510f98a6a1fabab" title="Cholesky factorisation of a symmetric matrix positive-definate matrix: single precision,...">utility_schol()</a>  <br /></td></tr>
<tr class="separator:ga417de323318b34b34595c4804ad6ee7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0b45ee898c3f34d510f98a6a1fabab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga8e0b45ee898c3f34d510f98a6a1fabab">utility_schol</a> (void *const hWork, const float *A, const int dim, float *X)</td></tr>
<tr class="memdesc:ga8e0b45ee898c3f34d510f98a6a1fabab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cholesky factorisation of a symmetric matrix positive-definate matrix: single precision, i.e.  <br /></td></tr>
<tr class="separator:ga8e0b45ee898c3f34d510f98a6a1fabab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf058da468353cebcd18e4324b3b2e95c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaf058da468353cebcd18e4324b3b2e95c">utility_cchol_create</a> (void **const phWork, int maxDim)</td></tr>
<tr class="memdesc:gaf058da468353cebcd18e4324b3b2e95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#gaabda3952e00d301d103bc3425cae3303" title="Cholesky factorisation of a hermitian positive-definate matrix: single precision complex,...">utility_cchol()</a>  <br /></td></tr>
<tr class="separator:gaf058da468353cebcd18e4324b3b2e95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade78ecba433e589f6abcfd8bcabdd69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaade78ecba433e589f6abcfd8bcabdd69">utility_cchol_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gaade78ecba433e589f6abcfd8bcabdd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#gaabda3952e00d301d103bc3425cae3303" title="Cholesky factorisation of a hermitian positive-definate matrix: single precision complex,...">utility_cchol()</a>  <br /></td></tr>
<tr class="separator:gaade78ecba433e589f6abcfd8bcabdd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabda3952e00d301d103bc3425cae3303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaabda3952e00d301d103bc3425cae3303">utility_cchol</a> (void *const hWork, const float_complex *A, const int dim, float_complex *X)</td></tr>
<tr class="memdesc:gaabda3952e00d301d103bc3425cae3303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cholesky factorisation of a hermitian positive-definate matrix: single precision complex, i.e.  <br /></td></tr>
<tr class="separator:gaabda3952e00d301d103bc3425cae3303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad359340ca68b286c8ca426ca7c03eb89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gad359340ca68b286c8ca426ca7c03eb89">utility_sdet_create</a> (void **const phWork, int maxN)</td></tr>
<tr class="memdesc:gad359340ca68b286c8ca426ca7c03eb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#gabbed89fdf056f2118a8049aa5a4ef8c6" title="Determinant of a Matrix, single precision, i,e.">utility_sdet()</a>  <br /></td></tr>
<tr class="separator:gad359340ca68b286c8ca426ca7c03eb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf27e2d85ea960871bdadf0be409d0d14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaf27e2d85ea960871bdadf0be409d0d14">utility_sdet_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gaf27e2d85ea960871bdadf0be409d0d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#gabbed89fdf056f2118a8049aa5a4ef8c6" title="Determinant of a Matrix, single precision, i,e.">utility_sdet()</a>  <br /></td></tr>
<tr class="separator:gaf27e2d85ea960871bdadf0be409d0d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbed89fdf056f2118a8049aa5a4ef8c6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gabbed89fdf056f2118a8049aa5a4ef8c6">utility_sdet</a> (void *const hWork, float *A, int N)</td></tr>
<tr class="memdesc:gabbed89fdf056f2118a8049aa5a4ef8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determinant of a Matrix, single precision, i,e.  <br /></td></tr>
<tr class="separator:gabbed89fdf056f2118a8049aa5a4ef8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccaa616abd327ecf800ed5eccbd0ceb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaccaa616abd327ecf800ed5eccbd0ceb6">utility_ddet_create</a> (void **const phWork, int maxN)</td></tr>
<tr class="memdesc:gaccaa616abd327ecf800ed5eccbd0ceb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga0973535862b0f4ec7ba68810bb65ddcf" title="Determinant of a Matrix, double precision, i,e.">utility_ddet()</a>  <br /></td></tr>
<tr class="separator:gaccaa616abd327ecf800ed5eccbd0ceb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bffb9d694334a27d46584414fb51d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga1bffb9d694334a27d46584414fb51d0c">utility_ddet_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga1bffb9d694334a27d46584414fb51d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga0973535862b0f4ec7ba68810bb65ddcf" title="Determinant of a Matrix, double precision, i,e.">utility_ddet()</a>  <br /></td></tr>
<tr class="separator:ga1bffb9d694334a27d46584414fb51d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0973535862b0f4ec7ba68810bb65ddcf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga0973535862b0f4ec7ba68810bb65ddcf">utility_ddet</a> (void *const hWork, double *A, int N)</td></tr>
<tr class="memdesc:ga0973535862b0f4ec7ba68810bb65ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determinant of a Matrix, double precision, i,e.  <br /></td></tr>
<tr class="separator:ga0973535862b0f4ec7ba68810bb65ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62746f59cf7e134d0d9d64cec05791ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga62746f59cf7e134d0d9d64cec05791ae">utility_sinv_create</a> (void **const phWork, int maxN)</td></tr>
<tr class="memdesc:ga62746f59cf7e134d0d9d64cec05791ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga7ded692ae35912f07fda80681f302fd6" title="Matrix inversion: single precision, i.e.">utility_sinv()</a>  <br /></td></tr>
<tr class="separator:ga62746f59cf7e134d0d9d64cec05791ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeefe466110dad799a2722990d04e02f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaeefe466110dad799a2722990d04e02f4">utility_sinv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gaeefe466110dad799a2722990d04e02f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga7ded692ae35912f07fda80681f302fd6" title="Matrix inversion: single precision, i.e.">utility_sinv()</a>  <br /></td></tr>
<tr class="separator:gaeefe466110dad799a2722990d04e02f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ded692ae35912f07fda80681f302fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga7ded692ae35912f07fda80681f302fd6">utility_sinv</a> (void *const hWork, float *A, float *B, const int N)</td></tr>
<tr class="memdesc:ga7ded692ae35912f07fda80681f302fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix inversion: single precision, i.e.  <br /></td></tr>
<tr class="separator:ga7ded692ae35912f07fda80681f302fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6ef7004b35ef7f7c3cbc9b066b9ca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga0b6ef7004b35ef7f7c3cbc9b066b9ca6">utility_dinv_create</a> (void **const phWork, int maxN)</td></tr>
<tr class="memdesc:ga0b6ef7004b35ef7f7c3cbc9b066b9ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga06952e48c6f327c4b84363b872549fe7" title="Matrix inversion: double precision, i.e.">utility_dinv()</a>  <br /></td></tr>
<tr class="separator:ga0b6ef7004b35ef7f7c3cbc9b066b9ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa999fc9276a770c4954eb1a618fab5dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#gaa999fc9276a770c4954eb1a618fab5dd">utility_dinv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:gaa999fc9276a770c4954eb1a618fab5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga06952e48c6f327c4b84363b872549fe7" title="Matrix inversion: double precision, i.e.">utility_dinv()</a>  <br /></td></tr>
<tr class="separator:gaa999fc9276a770c4954eb1a618fab5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06952e48c6f327c4b84363b872549fe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga06952e48c6f327c4b84363b872549fe7">utility_dinv</a> (void *const hWork, double *A, double *B, const int N)</td></tr>
<tr class="memdesc:ga06952e48c6f327c4b84363b872549fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix inversion: double precision, i.e.  <br /></td></tr>
<tr class="separator:ga06952e48c6f327c4b84363b872549fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c664e352f320721ca98790a828379a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga9c664e352f320721ca98790a828379a0">utility_cinv_create</a> (void **const phWork, int maxN)</td></tr>
<tr class="memdesc:ga9c664e352f320721ca98790a828379a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Optional) Pre-allocate the working struct used by <a class="el" href="group___utilities.html#ga206dec6445519c3d2e3a72d760442a93" title="Matrix inversion: double precision complex, i.e.">utility_cinv()</a>  <br /></td></tr>
<tr class="separator:ga9c664e352f320721ca98790a828379a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5873f3ef44af0ace11e4e2f8a766166e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga5873f3ef44af0ace11e4e2f8a766166e">utility_cinv_destroy</a> (void **const phWork)</td></tr>
<tr class="memdesc:ga5873f3ef44af0ace11e4e2f8a766166e"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-allocate the working struct used by <a class="el" href="group___utilities.html#ga206dec6445519c3d2e3a72d760442a93" title="Matrix inversion: double precision complex, i.e.">utility_cinv()</a>  <br /></td></tr>
<tr class="separator:ga5873f3ef44af0ace11e4e2f8a766166e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206dec6445519c3d2e3a72d760442a93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utilities.html#ga206dec6445519c3d2e3a72d760442a93">utility_cinv</a> (void *const hWork, float_complex *A, float_complex *B, const int N)</td></tr>
<tr class="memdesc:ga206dec6445519c3d2e3a72d760442a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix inversion: double precision complex, i.e.  <br /></td></tr>
<tr class="separator:ga206dec6445519c3d2e3a72d760442a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wrappers for optimised linear algebra routines, utilising CBLAS and LAPACK, and/or SIMD intrinsics. </p>
<h2><a class="anchor" id="autotoc_md92"></a>
Dependencies</h2>
<p>A performance library comprising CBLAS and LAPACK routines is required by the module and, thus, also by SAF as a whole. Add one of the following FLAGS to your project's preprocessor definitions list in order to enable one of these suitable performance libraries, which must also be correctly linked to your project.</p><ul>
<li>SAF_USE_INTEL_MKL_LP64: to enable Intel's Math Kernel Library with the Fortran LAPACK interface</li>
<li>SAF_USE_INTEL_MKL_ILP64 same as SAF_USE_INTEL_MKL except using int64 and LAPACKE interface</li>
<li>SAF_USE_OPENBLAS_WITH_LAPACKE: to enable OpenBLAS with the LAPACKE interface</li>
<li>SAF_USE_APPLE_ACCELERATE: to enable the Accelerate framework with the Fortran LAPACK interface</li>
<li>SAF_USE_ATLAS: to enable ATLAS BLAS routines and ATLAS's CLAPACK interface</li>
</ul>
<dl class="section see"><dt>See also</dt><dd>More information can be found here: <a href="https://github.com/leomccormack/Spatial_Audio_Framework/docs">https://github.com/leomccormack/Spatial_Audio_Framework/docs</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Leo McCormack </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11.07.2016 </dd></dl>
<dl class="section user"><dt>License</dt><dd>ISC </dd></dl>

<p class="definition">Definition in file <a class="el" href="saf__utility__veclib_8c_source.html">saf_utility_veclib.c</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa85d0063826ded1109fbe6b6e029348e" name="aa85d0063826ded1109fbe6b6e029348e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85d0063826ded1109fbe6b6e029348e">&#9670;&#160;</a></span>SAF_INTEL_MKL_VML_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAF_INTEL_MKL_VML_MODE&#160;&#160;&#160;( VML_LA | VML_FTZDAZ_ON )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Taken from the Intel MKL VML developers reference documentation: The flag(s) that can be passed to Intel VML functions: </p>
<ul>
<li>Faster processing of denormalized inputs: VML_FTZDAZ_ON || VML_FTZDAZ_OFF</li>
<li>High Accuracy (VML_HA), the default mode</li>
<li>Low Accuracy (VML_LA), which improves performance by reducing accuracy of the two least significant bits</li>
<li>Enhanced Performance (VML_EP), which provides better performance at the cost of significantly reduced accuracy. Approximately half of the bits in the mantissa are correct</li>
</ul>
<p>Note that using the EP mode does not guarantee accurate processing of corner cases and special values. Although the default accuracy is HA, LA is sufficient in most cases. For applications that require less accuracy (for example, media applications, some Monte Carlo simulations, etc.), the EP mode may be sufficient.</p>
<p>Note that this default SAF_INTEL_MKL_VML_MODE value can be overriden. </p>

<p class="definition">Definition at line <a class="el" href="saf__utility__veclib_8c_source.html#l00092">92</a> of file <a class="el" href="saf__utility__veclib_8c_source.html">saf_utility_veclib.c</a>.</p>

</div>
</div>
<a id="a62af0907d66bd565ec7a82efc8217ce5" name="a62af0907d66bd565ec7a82efc8217ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62af0907d66bd565ec7a82efc8217ce5">&#9670;&#160;</a></span>SAF_VECLIB_USE_LAPACK_FORTRAN_INTERFACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAF_VECLIB_USE_LAPACK_FORTRAN_INTERFACE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LAPACK interface. </p>

<p class="definition">Definition at line <a class="el" href="saf__utility__veclib_8c_source.html#l00054">54</a> of file <a class="el" href="saf__utility__veclib_8c_source.html">saf_utility_veclib.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a276629847a41b280b9d23b05b0a161e9" name="a276629847a41b280b9d23b05b0a161e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276629847a41b280b9d23b05b0a161e9">&#9670;&#160;</a></span>veclib_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="saf__utility__veclib_8c.html#a276629847a41b280b9d23b05b0a161e9">veclib_double</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>real: 8-bytes </p>

<p class="definition">Definition at line <a class="el" href="saf__utility__veclib_8c_source.html#l00110">110</a> of file <a class="el" href="saf__utility__veclib_8c_source.html">saf_utility_veclib.c</a>.</p>

</div>
</div>
<a id="a8b3637f07b00295a2e137f60a7afe0e4" name="a8b3637f07b00295a2e137f60a7afe0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3637f07b00295a2e137f60a7afe0e4">&#9670;&#160;</a></span>veclib_double_complex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MKL_Complex16 <a class="el" href="saf__utility__veclib_8c.html#a8b3637f07b00295a2e137f60a7afe0e4">veclib_double_complex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>complex: 16-bytes </p>

<p class="definition">Definition at line <a class="el" href="saf__utility__veclib_8c_source.html#l00112">112</a> of file <a class="el" href="saf__utility__veclib_8c_source.html">saf_utility_veclib.c</a>.</p>

</div>
</div>
<a id="ad4916c87c8ec713c92d69bfaebef60b1" name="ad4916c87c8ec713c92d69bfaebef60b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4916c87c8ec713c92d69bfaebef60b1">&#9670;&#160;</a></span>veclib_float</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="saf__utility__veclib_8c.html#ad4916c87c8ec713c92d69bfaebef60b1">veclib_float</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>real: 4-bytes </p>

<p class="definition">Definition at line <a class="el" href="saf__utility__veclib_8c_source.html#l00109">109</a> of file <a class="el" href="saf__utility__veclib_8c_source.html">saf_utility_veclib.c</a>.</p>

</div>
</div>
<a id="a96a92f56e80caec41cbe4a2002549b1f" name="a96a92f56e80caec41cbe4a2002549b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a92f56e80caec41cbe4a2002549b1f">&#9670;&#160;</a></span>veclib_float_complex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MKL_Complex8 <a class="el" href="saf__utility__veclib_8c.html#a96a92f56e80caec41cbe4a2002549b1f">veclib_float_complex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>complex: 8-bytes </p>

<p class="definition">Definition at line <a class="el" href="saf__utility__veclib_8c_source.html#l00111">111</a> of file <a class="el" href="saf__utility__veclib_8c_source.html">saf_utility_veclib.c</a>.</p>

</div>
</div>
<a id="a8a1892647cd90c5d7d67575fcfd149fa" name="a8a1892647cd90c5d7d67575fcfd149fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1892647cd90c5d7d67575fcfd149fa">&#9670;&#160;</a></span>veclib_int</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MKL_INT <a class="el" href="saf__utility__veclib_8c.html#a8a1892647cd90c5d7d67575fcfd149fa">veclib_int</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>integer: 4-bytes </p>

<p class="definition">Definition at line <a class="el" href="saf__utility__veclib_8c_source.html#l00105">105</a> of file <a class="el" href="saf__utility__veclib_8c_source.html">saf_utility_veclib.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_644e041c3a6521da7b27eba0e4eb2b95.html">framework</a></li><li class="navelem"><a class="el" href="dir_56553b6b74e7f4a7717200a52c59b140.html">modules</a></li><li class="navelem"><a class="el" href="dir_ba0a5884162be49ca564693d469c3119.html">saf_utilities</a></li><li class="navelem"><a class="el" href="saf__utility__veclib_8c.html">saf_utility_veclib.c</a></li>
    <li class="footer">Generated on Wed Feb 22 2023 12:02:09 for SAF by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
      $(document).ready(function(){
         toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
         toggleButton.title = "Toggle Light/Dark Mode"
         document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
     })
  })
</script>
</body>
</html>
