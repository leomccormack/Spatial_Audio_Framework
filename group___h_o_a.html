<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spatial_Audio_Framework: saf_hoa</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomDoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Spatial_Audio_Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___h_o_a.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">saf_hoa</div>  </div>
</div><!--header-->
<div class="contents">

<p>Higher-order Ambisonics module.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:saf__hoa_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8c.html">saf_hoa.c</a></td></tr>
<tr class="memdesc:saf__hoa_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public source for the higher-order Ambisonics module (<a class="el" href="saf_8h.html#a9c2c7080a25d54c9d7bc99588935ea8f" title="SAF Module: HOA.">SAF_HOA_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:saf__hoa_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html">saf_hoa.h</a></td></tr>
<tr class="memdesc:saf__hoa_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main header for the higher-order Ambisonics module (<a class="el" href="saf_8h.html#a9c2c7080a25d54c9d7bc99588935ea8f" title="SAF Module: HOA.">SAF_HOA_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:saf__hoa__internal_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa__internal_8c.html">saf_hoa_internal.c</a></td></tr>
<tr class="memdesc:saf__hoa__internal_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal source for the higher-order Ambisonics module (<a class="el" href="saf_8h.html#a9c2c7080a25d54c9d7bc99588935ea8f" title="SAF Module: HOA.">SAF_HOA_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:saf__hoa__internal_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa__internal_8h.html">saf_hoa_internal.h</a></td></tr>
<tr class="memdesc:saf__hoa__internal_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal header for the higher-order Ambisonics module (<a class="el" href="saf_8h.html#a9c2c7080a25d54c9d7bc99588935ea8f" title="SAF Module: HOA.">SAF_HOA_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa9bfe259decc1175b881c63f05edfae2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#gaa9bfe259decc1175b881c63f05edfae2">LOUDSPEAKER_AMBI_DECODER_METHODS</a> { <br />
&#160;&#160;<a class="el" href="group___h_o_a.html#ggaa9bfe259decc1175b881c63f05edfae2aa1dad6c278efa25907a0b64fb2942e26">LOUDSPEAKER_DECODER_DEFAULT</a>, 
<a class="el" href="group___h_o_a.html#ggaa9bfe259decc1175b881c63f05edfae2a743482262e1deb4c4511d2a9cbaddff6">LOUDSPEAKER_DECODER_SAD</a>, 
<a class="el" href="group___h_o_a.html#ggaa9bfe259decc1175b881c63f05edfae2ae1f628a0188a79ae586ae270a0a8b508">LOUDSPEAKER_DECODER_MMD</a>, 
<a class="el" href="group___h_o_a.html#ggaa9bfe259decc1175b881c63f05edfae2aa1e10487b21890502a1c72b34d2b7add">LOUDSPEAKER_DECODER_EPAD</a>, 
<br />
&#160;&#160;<a class="el" href="group___h_o_a.html#ggaa9bfe259decc1175b881c63f05edfae2a30fc2a59a858885b6651fd5a1fd34145">LOUDSPEAKER_DECODER_ALLRAD</a>
<br />
 }</td></tr>
<tr class="memdesc:gaa9bfe259decc1175b881c63f05edfae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ambisonic decoding options for loudspeaker playback.  <a href="group___h_o_a.html#gaa9bfe259decc1175b881c63f05edfae2">More...</a><br /></td></tr>
<tr class="separator:gaa9bfe259decc1175b881c63f05edfae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6116ef26ca8f592af4e81f5f963116"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a> { <br />
&#160;&#160;<a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116ab9d8239b3e918ada247720015cee827f">BINAURAL_DECODER_DEFAULT</a>, 
<a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116a25059f43250b90fb659563953d6e52a4">BINAURAL_DECODER_LS</a>, 
<a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116aea7d5ff9e0fec9c3e86274cde48a6436">BINAURAL_DECODER_LSDIFFEQ</a>, 
<a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116ab52d181ecdf9d10fcb9c5d761cac8a98">BINAURAL_DECODER_SPR</a>, 
<br />
&#160;&#160;<a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457">BINAURAL_DECODER_TA</a>, 
<a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116a02f30e94818bd69708ce020110589ce4">BINAURAL_DECODER_MAGLS</a>
<br />
 }</td></tr>
<tr class="memdesc:gaeb6116ef26ca8f592af4e81f5f963116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ambisonic decoding options for binaural/headphone playback.  <a href="group___h_o_a.html#gaeb6116ef26ca8f592af4e81f5f963116">More...</a><br /></td></tr>
<tr class="separator:gaeb6116ef26ca8f592af4e81f5f963116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736d1bf23b9d8a0b2018888b96295591"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a> { <a class="el" href="group___h_o_a.html#gga736d1bf23b9d8a0b2018888b96295591a59dc12dec2431faddbf49fa9af554dd7">HOA_CH_ORDER_ACN</a>, 
<a class="el" href="group___h_o_a.html#gga736d1bf23b9d8a0b2018888b96295591a2c3c6a04f29de60a9cb2e98853bb0e6e">HOA_CH_ORDER_FUMA</a>
 }</td></tr>
<tr class="memdesc:ga736d1bf23b9d8a0b2018888b96295591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available Ambisonic channel ordering conventions.  <a href="group___h_o_a.html#ga736d1bf23b9d8a0b2018888b96295591">More...</a><br /></td></tr>
<tr class="separator:ga736d1bf23b9d8a0b2018888b96295591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad26ea0ae544afa82568f7d6a51303f52"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a> { <a class="el" href="group___h_o_a.html#ggad26ea0ae544afa82568f7d6a51303f52afd66a843a7e726beb405e37649bc24d6">HOA_NORM_N3D</a>, 
<a class="el" href="group___h_o_a.html#ggad26ea0ae544afa82568f7d6a51303f52a9f7d4d31d27255bf7df49c21234b82e4">HOA_NORM_SN3D</a>, 
<a class="el" href="group___h_o_a.html#ggad26ea0ae544afa82568f7d6a51303f52a5f31b11f5e519ab3fb25ecc2d7eaee93">HOA_NORM_FUMA</a>
 }</td></tr>
<tr class="memdesc:gad26ea0ae544afa82568f7d6a51303f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available Ambisonic normalisation conventions.  <a href="group___h_o_a.html#gad26ea0ae544afa82568f7d6a51303f52">More...</a><br /></td></tr>
<tr class="separator:gad26ea0ae544afa82568f7d6a51303f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga567162a2a735a8c95be9729d40c1c1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#ga567162a2a735a8c95be9729d40c1c1d9">convertHOAChannelConvention</a> (float *insig, int order, int signalLength, <a class="el" href="group___h_o_a.html#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a> inConvention, <a class="el" href="group___h_o_a.html#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a> outConvention)</td></tr>
<tr class="memdesc:ga567162a2a735a8c95be9729d40c1c1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an Ambisonic signal from one channel ordering convention to another.  <a href="group___h_o_a.html#ga567162a2a735a8c95be9729d40c1c1d9">More...</a><br /></td></tr>
<tr class="separator:ga567162a2a735a8c95be9729d40c1c1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64fac66ae4e7564551f1f04378726d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#gae64fac66ae4e7564551f1f04378726d4">convertHOANormConvention</a> (float *insig, int order, int signalLength, <a class="el" href="group___h_o_a.html#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a> inConvention, <a class="el" href="group___h_o_a.html#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a> outConvention)</td></tr>
<tr class="memdesc:gae64fac66ae4e7564551f1f04378726d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an Ambisonic signal from one normalisation convention to another.  <a href="group___h_o_a.html#gae64fac66ae4e7564551f1f04378726d4">More...</a><br /></td></tr>
<tr class="separator:gae64fac66ae4e7564551f1f04378726d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2804e1b897727e3ed1cd0d6dc74d179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#gac2804e1b897727e3ed1cd0d6dc74d179">getRSH</a> (int order, float *dirs_deg, int nDirs, float *Y)</td></tr>
<tr class="memdesc:gac2804e1b897727e3ed1cd0d6dc74d179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes REAL spherical harmonics [1] for each given direction on the unit sphere.  <a href="group___h_o_a.html#gac2804e1b897727e3ed1cd0d6dc74d179">More...</a><br /></td></tr>
<tr class="separator:gac2804e1b897727e3ed1cd0d6dc74d179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf095b87aecb2c38ce5014669c70d4f6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#gaf095b87aecb2c38ce5014669c70d4f6f">getRSH_recur</a> (int order, float *dirs_deg, int nDirs, float *Y)</td></tr>
<tr class="memdesc:gaf095b87aecb2c38ce5014669c70d4f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes REAL spherical harmonics [1] for each given direction on the unit sphere.  <a href="group___h_o_a.html#gaf095b87aecb2c38ce5014669c70d4f6f">More...</a><br /></td></tr>
<tr class="separator:gaf095b87aecb2c38ce5014669c70d4f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2dc357da0a7df362e1d53a91936955c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#gaf2dc357da0a7df362e1d53a91936955c">getMaxREweights</a> (int order, int diagMtxFlag, float *a_n)</td></tr>
<tr class="memdesc:gaf2dc357da0a7df362e1d53a91936955c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weights required to manipulate a hyper-cardioid beam-pattern, such that it has maximum energy in the given look-direction.  <a href="group___h_o_a.html#gaf2dc357da0a7df362e1d53a91936955c">More...</a><br /></td></tr>
<tr class="separator:gaf2dc357da0a7df362e1d53a91936955c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c5ef22cd1066f447256dcb0ba7f76a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#ga7c5ef22cd1066f447256dcb0ba7f76a2">getLoudspeakerDecoderMtx</a> (float *ls_dirs_deg, int nLS, <a class="el" href="group___h_o_a.html#gaa9bfe259decc1175b881c63f05edfae2">LOUDSPEAKER_AMBI_DECODER_METHODS</a> method, int order, int enableMaxrE, float *decMtx)</td></tr>
<tr class="memdesc:ga7c5ef22cd1066f447256dcb0ba7f76a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an ambisonic decoding matrix of a specific order, for a given loudspeaker layout.  <a href="group___h_o_a.html#ga7c5ef22cd1066f447256dcb0ba7f76a2">More...</a><br /></td></tr>
<tr class="separator:ga7c5ef22cd1066f447256dcb0ba7f76a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga291c22e193e90d410b9ec3c5f3a01a11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#ga291c22e193e90d410b9ec3c5f3a01a11">getBinauralAmbiDecoderMtx</a> (float_complex *hrtfs, float *hrtf_dirs_deg, int N_dirs, int N_bands, <a class="el" href="group___h_o_a.html#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a> method, int order, float *freqVector, float *itd_s, float *weights, int enableDiffCM, int enableMaxrE, float_complex *decMtx)</td></tr>
<tr class="memdesc:ga291c22e193e90d410b9ec3c5f3a01a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes binaural ambisonic decoding matrices (one per frequency) at a specific order, for a given HRTF set.  <a href="group___h_o_a.html#ga291c22e193e90d410b9ec3c5f3a01a11">More...</a><br /></td></tr>
<tr class="separator:ga291c22e193e90d410b9ec3c5f3a01a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa84a59d7917e33747541580167c02e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#gaa84a59d7917e33747541580167c02e76">getBinauralAmbiDecoderFilters</a> (float_complex *hrtfs, float *hrtf_dirs_deg, int N_dirs, int fftSize, float fs, <a class="el" href="group___h_o_a.html#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a> method, int order, float *itd_s, float *weights, int enableDiffCM, int enableMaxrE, float *decFilters)</td></tr>
<tr class="memdesc:gaa84a59d7917e33747541580167c02e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes binaural ambisonic decoding filters for a given HRTF set.  <a href="group___h_o_a.html#gaa84a59d7917e33747541580167c02e76">More...</a><br /></td></tr>
<tr class="separator:gaa84a59d7917e33747541580167c02e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc8fcc9d1b9981fbc9e6097c97495d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_a.html#ga1cc8fcc9d1b9981fbc9e6097c97495d4">applyDiffCovMatching</a> (float_complex *hrtfs, float *hrtf_dirs_deg, int N_dirs, int N_bands, int order, float *weights, float_complex *decMtx)</td></tr>
<tr class="memdesc:ga1cc8fcc9d1b9981fbc9e6097c97495d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes a diffuse-field covariance constraint on a given binaural decoding matrix, as described in [1].  <a href="group___h_o_a.html#ga1cc8fcc9d1b9981fbc9e6097c97495d4">More...</a><br /></td></tr>
<tr class="separator:ga1cc8fcc9d1b9981fbc9e6097c97495d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Higher-order Ambisonics module. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaeb6116ef26ca8f592af4e81f5f963116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb6116ef26ca8f592af4e81f5f963116">&#9670;&nbsp;</a></span>BINAURAL_AMBI_DECODER_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_o_a.html#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ambisonic decoding options for binaural/headphone playback. </p>
<dl class="section note"><dt>Note</dt><dd>A more detailed description of each method may be found in <a class="el" href="saf__hoa__internal_8h.html" title="Internal header for the higher-order Ambisonics module (SAF_HOA_MODULE)">saf_hoa_internal.h</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>[1] Z. Ben-Hur, F. Brinkmann, J. Sheaffer, S. Weinzierl, and B. Rafaely, "Spectral equalization in binaural signals represented by order-
         truncated spherical harmonics" The Journal of the Acoustical Society of America, vol. 141, no. 6, pp. 4087&ndash;4096, 2017. </dd>
<dd>
[2] B. Bernschutz, A. V. Giner, C. Po"rschmann, and J. Arend, "Binaural reproduction of plane waves with reduced modal order" Acta Acustica united with Acustica, vol. 100, no. 5, pp. 972&ndash;983, 2014. </dd>
<dd>
[3] Zaunschirm M, Scho"rkhuber C, Ho"ldrich R. Binaural rendering of Ambisonic signals by head-related impulse response time alignment and a diffuseness constraint. The Journal of the Acoustical Society of America. 2018 Jun 19;143(6):3616-27 </dd>
<dd>
[4] Scho"rkhuber C, Zaunschirm M, Ho"ldrich R. Binaural Rendering of Ambisonic Signals via Magnitude Least Squares. InProceedings of the DAGA 2018 (Vol. 44, pp. 339-342). </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116ab9d8239b3e918ada247720015cee827f"></a>BINAURAL_DECODER_DEFAULT&#160;</td><td class="fielddoc"><p>The default decoder is <a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116a25059f43250b90fb659563953d6e52a4" title="Least-squares (LS) decoder.">BINAURAL_DECODER_LS</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116a25059f43250b90fb659563953d6e52a4"></a>BINAURAL_DECODER_LS&#160;</td><td class="fielddoc"><p>Least-squares (LS) decoder. </p>
<p>The simplest binaural decoder. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116aea7d5ff9e0fec9c3e86274cde48a6436"></a>BINAURAL_DECODER_LSDIFFEQ&#160;</td><td class="fielddoc"><p>Least-squares (LS) decoder with diffuse-field spectral equalisation [1]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116ab52d181ecdf9d10fcb9c5d761cac8a98"></a>BINAURAL_DECODER_SPR&#160;</td><td class="fielddoc"><p>Spatial resampling decoder (on the same lines as the virtual loudspeaker approach) [2]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457"></a>BINAURAL_DECODER_TA&#160;</td><td class="fielddoc"><p>Time-alignment decoder [3]. </p>
<p>Relies on discarding the phase information of the HRTFs, past the frequency at which humans are less sensitive to inter-aural time differences. Therefore, the least-squares fitting priorites matching the interaural level differences (ILDs), rather than the interaural time differences (ITDs). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116a02f30e94818bd69708ce020110589ce4"></a>BINAURAL_DECODER_MAGLS&#160;</td><td class="fielddoc"><p>Magnitude least-squares decoder [4]. </p>
<p>On similar lines to the time- alignment decoder, but differing in its execution. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8h_source.html#l00132">132</a> of file <a class="el" href="saf__hoa_8h_source.html">saf_hoa.h</a>.</p>

</div>
</div>
<a id="ga736d1bf23b9d8a0b2018888b96295591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga736d1bf23b9d8a0b2018888b96295591">&#9670;&nbsp;</a></span>HOA_CH_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_o_a.html#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available Ambisonic channel ordering conventions. </p>
<dl class="section note"><dt>Note</dt><dd>ACN channel ordering with SN3D normalisation is often collectively referred to as the 'AmbiX' format. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>FuMa is a deprecated legacy format and is only supported for first- order! The recommended Ambisonic conventions are ACN with N3D/SN3D normalisation. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga736d1bf23b9d8a0b2018888b96295591a59dc12dec2431faddbf49fa9af554dd7"></a>HOA_CH_ORDER_ACN&#160;</td><td class="fielddoc"><p>Ambisonic Channel numbering (ACN) convention, which is employed by all spherical harmonic related functions in SAF. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga736d1bf23b9d8a0b2018888b96295591a2c3c6a04f29de60a9cb2e98853bb0e6e"></a>HOA_CH_ORDER_FUMA&#160;</td><td class="fielddoc"><p>Furse-Malham (FuMa) convention, often used by older recordings. </p>
<p>The convention follows the WXYZ ordering of the omni and dipoles, and is suitable only for 1st order. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8h_source.html#l00175">175</a> of file <a class="el" href="saf__hoa_8h_source.html">saf_hoa.h</a>.</p>

</div>
</div>
<a id="gad26ea0ae544afa82568f7d6a51303f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad26ea0ae544afa82568f7d6a51303f52">&#9670;&nbsp;</a></span>HOA_NORM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_o_a.html#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available Ambisonic normalisation conventions. </p>
<dl class="section note"><dt>Note</dt><dd>ACN channel ordering with SN3D normalisation is often collectively referred to as the 'AmbiX' format. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>FuMa is a deprecated legacy format and is only supported for first- order! The recommended Ambisonic conventions are ACN with N3D/SN3D normalisation. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad26ea0ae544afa82568f7d6a51303f52afd66a843a7e726beb405e37649bc24d6"></a>HOA_NORM_N3D&#160;</td><td class="fielddoc"><p>Orthonormalised (N3D) convention, which is the default convention used by SAF. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad26ea0ae544afa82568f7d6a51303f52a9f7d4d31d27255bf7df49c21234b82e4"></a>HOA_NORM_SN3D&#160;</td><td class="fielddoc"><p>Schmidt semi-normalisation (SN3D) convention, as used by the AmbiX standard. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad26ea0ae544afa82568f7d6a51303f52a5f31b11f5e519ab3fb25ecc2d7eaee93"></a>HOA_NORM_FUMA&#160;</td><td class="fielddoc"><p>Furse-Malham (FuMa) convention. </p>
<p>This is similar to SN3D (at first-order), except theres an additional 1/sqrt(2) scaling applied to the omni. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8h_source.html#l00195">195</a> of file <a class="el" href="saf__hoa_8h_source.html">saf_hoa.h</a>.</p>

</div>
</div>
<a id="gaa9bfe259decc1175b881c63f05edfae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9bfe259decc1175b881c63f05edfae2">&#9670;&nbsp;</a></span>LOUDSPEAKER_AMBI_DECODER_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_o_a.html#gaa9bfe259decc1175b881c63f05edfae2">LOUDSPEAKER_AMBI_DECODER_METHODS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ambisonic decoding options for loudspeaker playback. </p>
<p>Note that the MDD and EPAD decoding options revert back to "SAD" if the loudspeakers are uniformly distributed on the sphere. The benefits afforded by MMD, EPAD [1], and AllRAD [2] relate to their improved performance when using irregular loudspeaker arrangements.</p>
<dl class="section see"><dt>See also</dt><dd>[1] Zotter F, Pomberger H, Noisternig M. Energy&ndash;preserving ambisonic decoding. Acta Acustica united with Acustica. 2012 Jan 1; 98(1):37-47. </dd>
<dd>
[2] Zotter F, Frank M. All-round ambisonic panning and decoding. Journal of the audio engineering society. 2012 Nov 26; 60(10):807-20. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa9bfe259decc1175b881c63f05edfae2aa1dad6c278efa25907a0b64fb2942e26"></a>LOUDSPEAKER_DECODER_DEFAULT&#160;</td><td class="fielddoc"><p>The default decoder is <a class="el" href="group___h_o_a.html#ggaa9bfe259decc1175b881c63f05edfae2a743482262e1deb4c4511d2a9cbaddff6" title="Sampling Ambisonic Decoder (SAD): transpose of the loudspeaker spherical harmonic matrix,...">LOUDSPEAKER_DECODER_SAD</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9bfe259decc1175b881c63f05edfae2a743482262e1deb4c4511d2a9cbaddff6"></a>LOUDSPEAKER_DECODER_SAD&#160;</td><td class="fielddoc"><p>Sampling Ambisonic Decoder (SAD): transpose of the loudspeaker spherical harmonic matrix, scaled by the number of loudspeakers. </p>
<p>This is the simplest decoding approach, as it essentially just generates hyper- cardioid beamformers (aka virtual microphones) towards each loudspeaker direction. This approach is numerically robust to irregular loudspeaker arrangements. However, it does not preserve the energy of a source (or localisation cues) as it is panned around in different directions. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9bfe259decc1175b881c63f05edfae2ae1f628a0188a79ae586ae270a0a8b508"></a>LOUDSPEAKER_DECODER_MMD&#160;</td><td class="fielddoc"><p>Mode-Matching Decoder (MMD): pseudo-inverse of the loudspeaker spherical harmonic matrix. </p>
<p>Due to the pseudo-inverse, more signal energy is lent to regions on the surface of the sphere that are more sparsely populated with loudspeakers, since this is essentially a least-squares solution. Therefore, this approach can help balance out directional loudness differences when using slightly irregular setups. However, one must also be careful since loudspeakers that are far way from all the other loudspeakers (e.g. voice-of-god) may be given significantly more signal energy than expected. Therefore, this approach is not recommended for highly irregular loudspeaker arrangements </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9bfe259decc1175b881c63f05edfae2aa1e10487b21890502a1c72b34d2b7add"></a>LOUDSPEAKER_DECODER_EPAD&#160;</td><td class="fielddoc"><p>Energy-Preserving Ambisonic Decoder (EPAD) [1]. </p>
<p>This decoder aims to preserve the energy of a source, as it panned around to directions of the sphere; essentially, addressing the energy-preserving issues of the SAD and MMD decoding approaches, especially for irregular layouts. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9bfe259decc1175b881c63f05edfae2a30fc2a59a858885b6651fd5a1fd34145"></a>LOUDSPEAKER_DECODER_ALLRAD&#160;</td><td class="fielddoc"><p>All-Round Ambisonic Decoder (AllRAD): SAD decoding to t-design, panned for the target loudspeaker directions using VBAP [2]. </p>
<p>Perhaps the Ambisonic decoder we would most recommend for irregular loudspeaker layouts. Note, given a high (well... technically infinite) order, AllRAD will converge to VBAP. However, since lower-orders are employed in practice, AllRAD is not as spatially "sharp" as VBAP, but it will yield more consistent source spread when panning a source inbetween the loudspeakers. The approach is highly robust to irregular loudspeaker setups, and exhibits low directional error and good energy-preserving properties. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8h_source.html#l00060">60</a> of file <a class="el" href="saf__hoa_8h_source.html">saf_hoa.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1cc8fcc9d1b9981fbc9e6097c97495d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc8fcc9d1b9981fbc9e6097c97495d4">&#9670;&nbsp;</a></span>applyDiffCovMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void applyDiffCovMatching </td>
          <td>(</td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>hrtfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hrtf_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>decMtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imposes a diffuse-field covariance constraint on a given binaural decoding matrix, as described in [1]. </p>
<dl class="section note"><dt>Note</dt><dd>decMtx is altered in-place.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtfs</td><td>The HRTFs; FLAT: N_bands x <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x N_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtf_dirs_deg</td><td>HRTF directions; FLAT: N_dirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_dirs</td><td>Number of HRTF directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_bands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Integration weights (set to NULL if not available); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">decMtx</td><td>Decoding matrix; FLAT: N_bands x <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x (order+1)^2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Zaunschirm M, Scho"rkhuber C, Ho"ldrich R. Binaural rendering of Ambisonic signals by head-related impulse response time alignment and a diffuseness constraint. The Journal of the Acoustical Society of America. 2018 Jun 19;143(6):3616-27 </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00485">485</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="ga567162a2a735a8c95be9729d40c1c1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga567162a2a735a8c95be9729d40c1c1d9">&#9670;&nbsp;</a></span>convertHOAChannelConvention()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void convertHOAChannelConvention </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>insig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signalLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_o_a.html#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a>&#160;</td>
          <td class="paramname"><em>inConvention</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_o_a.html#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a>&#160;</td>
          <td class="paramname"><em>outConvention</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an Ambisonic signal from one channel ordering convention to another. </p>
<dl class="section warning"><dt>Warning</dt><dd>If one of the in/out conventions is FuMa, then only the first 4 channels are converted, and any remaining channels of 'insig' are set to zeros (i.e. FuMa is strictly first-order only in SAF). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>insig is converted "in-place". Also, if the in/out conventions are the same, then the function is bypassed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">insig</td><td>Input signal with the channel ordering convention of: inConvention; FLAT: (order+1)^2 x signalLength </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Ambisonic order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalLength</td><td>Signal length in samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inConvention</td><td>Channel order convention of input signals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outConvention</td><td>Channel order convention of output signals </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00038">38</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gae64fac66ae4e7564551f1f04378726d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae64fac66ae4e7564551f1f04378726d4">&#9670;&nbsp;</a></span>convertHOANormConvention()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void convertHOANormConvention </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>insig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signalLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_o_a.html#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a>&#160;</td>
          <td class="paramname"><em>inConvention</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_o_a.html#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a>&#160;</td>
          <td class="paramname"><em>outConvention</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an Ambisonic signal from one normalisation convention to another. </p>
<dl class="section warning"><dt>Warning</dt><dd>If one of the in/out conventions is FuMa, then only the first 4 channels are converted, and any remaining channels of 'insig' are set to zeros (i.e. FuMa is strictly first-order only in SAF). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>insig is converted "in-place". Also, if the in/out conventions are the same, then the function is bypassed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">insig</td><td>Input signal with the channel ordering convention of: inConvention, which should be converted to: outConvention, "in-place"; FLAT: (order+1)^2 x signalLength </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Ambisonic order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalLength</td><td>Signal length in samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inConvention</td><td>Normalisation convention of the input signals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outConvention</td><td>Normalisation convention of the output signals </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00094">94</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gaa84a59d7917e33747541580167c02e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa84a59d7917e33747541580167c02e76">&#9670;&nbsp;</a></span>getBinauralAmbiDecoderFilters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getBinauralAmbiDecoderFilters </td>
          <td>(</td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>hrtfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hrtf_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fftSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_o_a.html#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>itd_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableDiffCM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableMaxrE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>decFilters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes binaural ambisonic decoding filters for a given HRTF set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtfs</td><td>The HRTFs; FLAT: (fftSize/2+1) x <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x N_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtf_dirs_deg</td><td>HRTF directions; FLAT: N_dirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_dirs</td><td>Number of HRTF directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fftSize</td><td>FFT size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fs</td><td>Sampling rate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Decoder method (see <a class="el" href="group___h_o_a.html#gaeb6116ef26ca8f592af4e81f5f963116" title="Ambisonic decoding options for binaural/headphone playback.">BINAURAL_AMBI_DECODER_METHODS</a> enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itd_s</td><td>Only needed for <a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457" title="Time-alignment decoder [3].">BINAURAL_DECODER_TA</a> decoder (can set to NULL if using different method); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Integration weights (set to NULL if not available); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableDiffCM</td><td>Set to '0' to disable diffuse correction, '1' to enable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableMaxrE</td><td>Set to '0' to disable maxRE weighting, '1' to enable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decFilters</td><td>Decoding filters; FLAT: <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x (order+1)^2 x fftSize </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00435">435</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="ga291c22e193e90d410b9ec3c5f3a01a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga291c22e193e90d410b9ec3c5f3a01a11">&#9670;&nbsp;</a></span>getBinauralAmbiDecoderMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getBinauralAmbiDecoderMtx </td>
          <td>(</td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>hrtfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hrtf_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_o_a.html#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>freqVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>itd_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableDiffCM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableMaxrE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>decMtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes binaural ambisonic decoding matrices (one per frequency) at a specific order, for a given HRTF set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtfs</td><td>The HRTFs; FLAT: N_bands x <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x N_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtf_dirs_deg</td><td>HRTF directions; FLAT: N_dirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_dirs</td><td>Number of HRTF directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_bands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Decoder method (see <a class="el" href="group___h_o_a.html#gaeb6116ef26ca8f592af4e81f5f963116" title="Ambisonic decoding options for binaural/headphone playback.">BINAURAL_AMBI_DECODER_METHODS</a> enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freqVector</td><td>Only needed for <a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457" title="Time-alignment decoder [3].">BINAURAL_DECODER_TA</a> or <a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116a02f30e94818bd69708ce020110589ce4" title="Magnitude least-squares decoder [4].">BINAURAL_DECODER_MAGLS</a> decoders (set to NULL if using a different method); N_bands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itd_s</td><td>Only needed for <a class="el" href="group___h_o_a.html#ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457" title="Time-alignment decoder [3].">BINAURAL_DECODER_TA</a> decoder (set to NULL if using different method); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Integration weights (set to NULL if not available); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableDiffCM</td><td>Set to '0' to disable diffuse correction, '1' to enable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableMaxrE</td><td>Set to '0' to disable maxRE weighting, '1' to enable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decMtx</td><td>Decoding matrices (one per frequency); FLAT: N_bands x <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x (order+1)^2 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00363">363</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="ga7c5ef22cd1066f447256dcb0ba7f76a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c5ef22cd1066f447256dcb0ba7f76a2">&#9670;&nbsp;</a></span>getLoudspeakerDecoderMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getLoudspeakerDecoderMtx </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ls_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_o_a.html#gaa9bfe259decc1175b881c63f05edfae2">LOUDSPEAKER_AMBI_DECODER_METHODS</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableMaxrE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>decMtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an ambisonic decoding matrix of a specific order, for a given loudspeaker layout. </p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000008">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#a5e73f4abcab45bb014c621804a6864a6" title="Testing to assure that (given a uniform loudspeaker layout), the SAD, MMD and EPAD decoders are all e...">test__getLoudspeakerDecoderMtx()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ls_dirs_deg</td><td>Loudspeaker directions in DEGREES [azi elev]; FLAT: nLS x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLS</td><td>Number of loudspeakers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Decoding method (see <a class="el" href="group___h_o_a.html#gaa9bfe259decc1175b881c63f05edfae2" title="Ambisonic decoding options for loudspeaker playback.">LOUDSPEAKER_AMBI_DECODER_METHODS</a> enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableMaxrE</td><td>Set to '0' to disable, '1' to enable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decMtx</td><td>Decoding matrix; FLAT: nLS x (order+1)^2 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00295">295</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gaf2dc357da0a7df362e1d53a91936955c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2dc357da0a7df362e1d53a91936955c">&#9670;&nbsp;</a></span>getMaxREweights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getMaxREweights </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>diagMtxFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weights required to manipulate a hyper-cardioid beam-pattern, such that it has maximum energy in the given look-direction. </p>
<p>Traditionally, due to the back lobes of beamformers when panning a source via Ambisonics encoding/decoding, there is unwanted energy given to loudspeakers directly opposite the true source direction. This max_rE weighting [1] essentially spatially "tapers" the spherical harmonic patterns used to generate said beams, reducing the contribution of the higher orders to the beam patterns. This results in worse spatial selectivity, as the width of the beam pattern main lobe is widened, however, the back lobes are also reduced; thus mitigating the aforementioned problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagMtxFlag</td><td>Set to '0' if you want the weights to be returned as a vector, or to '1' as a diagonal matrix instead. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_n</td><td>The max_rE weights, as a vector/diagonal matrix; (order+1)^2 x 1 OR FLAT: (order+1)^2 x (order+1)^2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Zotter F, Frank M. All-round ambisonic panning and decoding. Journal of the audio engineering society. 2012 Nov 26; 60(10):807-20. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00261">261</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gac2804e1b897727e3ed1cd0d6dc74d179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2804e1b897727e3ed1cd0d6dc74d179">&#9670;&nbsp;</a></span>getRSH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRSH </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes REAL spherical harmonics [1] for each given direction on the unit sphere. </p>
<p>The real spherical harmonics are computed WITHOUT the 1/sqrt(4*pi) term. i.e. max(omni) = 1. Also, compared to <a class="el" href="group___h_o_a.html#gaf095b87aecb2c38ce5014669c70d4f6f" title="Computes REAL spherical harmonics [1] for each given direction on the unit sphere.">getRSH_recur()</a>, this function uses <a class="el" href="group___s_h.html#ga1ff15ddf9e257b1f185421568ef349dd" title="Calculates unnormalised Legendre polynomials up to order N, for all values in vector x [1].">unnorm_legendreP()</a> and double precision, so is more suitable for determining 'Y' in an initialisation stage. This version is indeed slower, but more precise (especially for high orders).</p>
<dl class="section note"><dt>Note</dt><dd>This function is mainly intended for Ambisonics, due to the omission of the 1/sqrt(4*pi) scaling, and the directions are given in [azimuth elevation] (degrees). In Ambisonics literature, the format convention of 'Y' is referred to as ACN/N3D</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_deg</td><td>Directions on the sphere [azi, ELEVATION] convention, in DEGREES; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITHOUT the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00150">150</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gaf095b87aecb2c38ce5014669c70d4f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf095b87aecb2c38ce5014669c70d4f6f">&#9670;&nbsp;</a></span>getRSH_recur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRSH_recur </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes REAL spherical harmonics [1] for each given direction on the unit sphere. </p>
<p>The real spherical harmonics are computed WITHOUT the 1/sqrt(4*pi) term. i.e. max(omni) = 1. Also, Compared to <a class="el" href="group___h_o_a.html#gac2804e1b897727e3ed1cd0d6dc74d179" title="Computes REAL spherical harmonics [1] for each given direction on the unit sphere.">getRSH()</a>, this function uses <a class="el" href="group___s_h.html#ga3851842c7f6c520c3f645f0ae686443c" title="Calculates unnormalised Legendre polynomials up to order N, for all values in vector x.">unnorm_legendreP_recur()</a> and single precision, so is more suitable for determining 'Y' in a real-time loop. It sacrifices some precision, as numerical error propogates through the recursion, but it is much faster.</p>
<dl class="section note"><dt>Note</dt><dd>This function is mainly intended for Ambisonics, due to the omission of the 1/sqrt(4*pi) scaling, and the directions are given in [azimuth elevation] (degrees). In Ambisonics literature, the format convention of 'Y' is referred to as ACN/N3D</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_deg</td><td>Directions on the sphere [azi, ELEVATION] convention, in DEGREES; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITHOUT the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00181">181</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Oct 1 2020 12:31:16 for Spatial_Audio_Framework by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
