<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="google" content="notranslate" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SAF: saf_hoa</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-498Z1C2LX5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-498Z1C2LX5');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SAF
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group___h_o_a.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">saf_hoa</div></div>
</div><!--header-->
<div class="contents">

<p>Higher-order Ambisonics module.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8c.html">saf_hoa.c</a></td></tr>
<tr class="memdesc:saf__hoa_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public source for the higher-order Ambisonics module (<a class="el" href="saf_8h.html#a9c2c7080a25d54c9d7bc99588935ea8f" title="SAF Module: HOA.">SAF_HOA_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html">saf_hoa.h</a></td></tr>
<tr class="memdesc:saf__hoa_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main header for the higher-order Ambisonics module (<a class="el" href="saf_8h.html#a9c2c7080a25d54c9d7bc99588935ea8f" title="SAF Module: HOA.">SAF_HOA_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa__internal_8c.html">saf_hoa_internal.c</a></td></tr>
<tr class="memdesc:saf__hoa__internal_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal source for the higher-order Ambisonics module (<a class="el" href="saf_8h.html#a9c2c7080a25d54c9d7bc99588935ea8f" title="SAF Module: HOA.">SAF_HOA_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa__internal_8h.html">saf_hoa_internal.h</a></td></tr>
<tr class="memdesc:saf__hoa__internal_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal header for the higher-order Ambisonics module (<a class="el" href="saf_8h.html#a9c2c7080a25d54c9d7bc99588935ea8f" title="SAF Module: HOA.">SAF_HOA_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa9bfe259decc1175b881c63f05edfae2" id="r_gaa9bfe259decc1175b881c63f05edfae2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa9bfe259decc1175b881c63f05edfae2">LOUDSPEAKER_AMBI_DECODER_METHODS</a> { <br />
&#160;&#160;<a class="el" href="#ggaa9bfe259decc1175b881c63f05edfae2aa1dad6c278efa25907a0b64fb2942e26">LOUDSPEAKER_DECODER_DEFAULT</a>
, <a class="el" href="#ggaa9bfe259decc1175b881c63f05edfae2a743482262e1deb4c4511d2a9cbaddff6">LOUDSPEAKER_DECODER_SAD</a>
, <a class="el" href="#ggaa9bfe259decc1175b881c63f05edfae2ae1f628a0188a79ae586ae270a0a8b508">LOUDSPEAKER_DECODER_MMD</a>
, <a class="el" href="#ggaa9bfe259decc1175b881c63f05edfae2aa1e10487b21890502a1c72b34d2b7add">LOUDSPEAKER_DECODER_EPAD</a>
, <br />
&#160;&#160;<a class="el" href="#ggaa9bfe259decc1175b881c63f05edfae2a30fc2a59a858885b6651fd5a1fd34145">LOUDSPEAKER_DECODER_ALLRAD</a>
<br />
 }</td></tr>
<tr class="memdesc:gaa9bfe259decc1175b881c63f05edfae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ambisonic decoding options for loudspeaker playback.  <a href="#gaa9bfe259decc1175b881c63f05edfae2">More...</a><br /></td></tr>
<tr class="separator:gaa9bfe259decc1175b881c63f05edfae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6116ef26ca8f592af4e81f5f963116" id="r_gaeb6116ef26ca8f592af4e81f5f963116"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a> { <br />
&#160;&#160;<a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116ab9d8239b3e918ada247720015cee827f">BINAURAL_DECODER_DEFAULT</a>
, <a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116a25059f43250b90fb659563953d6e52a4">BINAURAL_DECODER_LS</a>
, <a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116aea7d5ff9e0fec9c3e86274cde48a6436">BINAURAL_DECODER_LSDIFFEQ</a>
, <a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116ab52d181ecdf9d10fcb9c5d761cac8a98">BINAURAL_DECODER_SPR</a>
, <br />
&#160;&#160;<a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457">BINAURAL_DECODER_TA</a>
, <a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116a02f30e94818bd69708ce020110589ce4">BINAURAL_DECODER_MAGLS</a>
<br />
 }</td></tr>
<tr class="memdesc:gaeb6116ef26ca8f592af4e81f5f963116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ambisonic decoding options for binaural/headphone playback.  <a href="#gaeb6116ef26ca8f592af4e81f5f963116">More...</a><br /></td></tr>
<tr class="separator:gaeb6116ef26ca8f592af4e81f5f963116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736d1bf23b9d8a0b2018888b96295591" id="r_ga736d1bf23b9d8a0b2018888b96295591"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a> { <a class="el" href="#gga736d1bf23b9d8a0b2018888b96295591a59dc12dec2431faddbf49fa9af554dd7">HOA_CH_ORDER_ACN</a>
, <a class="el" href="#gga736d1bf23b9d8a0b2018888b96295591a2c3c6a04f29de60a9cb2e98853bb0e6e">HOA_CH_ORDER_FUMA</a>
 }</td></tr>
<tr class="memdesc:ga736d1bf23b9d8a0b2018888b96295591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available Ambisonic channel ordering conventions.  <a href="#ga736d1bf23b9d8a0b2018888b96295591">More...</a><br /></td></tr>
<tr class="separator:ga736d1bf23b9d8a0b2018888b96295591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad26ea0ae544afa82568f7d6a51303f52" id="r_gad26ea0ae544afa82568f7d6a51303f52"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a> { <a class="el" href="#ggad26ea0ae544afa82568f7d6a51303f52afd66a843a7e726beb405e37649bc24d6">HOA_NORM_N3D</a>
, <a class="el" href="#ggad26ea0ae544afa82568f7d6a51303f52a9f7d4d31d27255bf7df49c21234b82e4">HOA_NORM_SN3D</a>
, <a class="el" href="#ggad26ea0ae544afa82568f7d6a51303f52a5f31b11f5e519ab3fb25ecc2d7eaee93">HOA_NORM_FUMA</a>
 }</td></tr>
<tr class="memdesc:gad26ea0ae544afa82568f7d6a51303f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available Ambisonic normalisation conventions.  <a href="#gad26ea0ae544afa82568f7d6a51303f52">More...</a><br /></td></tr>
<tr class="separator:gad26ea0ae544afa82568f7d6a51303f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga567162a2a735a8c95be9729d40c1c1d9" id="r_ga567162a2a735a8c95be9729d40c1c1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga567162a2a735a8c95be9729d40c1c1d9">convertHOAChannelConvention</a> (float *insig, int order, int signalLength, <a class="el" href="#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a> inConvention, <a class="el" href="#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a> outConvention)</td></tr>
<tr class="memdesc:ga567162a2a735a8c95be9729d40c1c1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an Ambisonic signal from one channel ordering convention to another.  <br /></td></tr>
<tr class="separator:ga567162a2a735a8c95be9729d40c1c1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64fac66ae4e7564551f1f04378726d4" id="r_gae64fac66ae4e7564551f1f04378726d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae64fac66ae4e7564551f1f04378726d4">convertHOANormConvention</a> (float *insig, int order, int signalLength, <a class="el" href="#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a> inConvention, <a class="el" href="#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a> outConvention)</td></tr>
<tr class="memdesc:gae64fac66ae4e7564551f1f04378726d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an Ambisonic signal from one normalisation convention to another.  <br /></td></tr>
<tr class="separator:gae64fac66ae4e7564551f1f04378726d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2804e1b897727e3ed1cd0d6dc74d179" id="r_gac2804e1b897727e3ed1cd0d6dc74d179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac2804e1b897727e3ed1cd0d6dc74d179">getRSH</a> (int order, float *dirs_deg, int nDirs, float *Y)</td></tr>
<tr class="memdesc:gac2804e1b897727e3ed1cd0d6dc74d179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes real-valued spherical harmonics [1] for each given direction on the unit sphere.  <br /></td></tr>
<tr class="separator:gac2804e1b897727e3ed1cd0d6dc74d179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf095b87aecb2c38ce5014669c70d4f6f" id="r_gaf095b87aecb2c38ce5014669c70d4f6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf095b87aecb2c38ce5014669c70d4f6f">getRSH_recur</a> (int order, float *dirs_deg, int nDirs, float *Y)</td></tr>
<tr class="memdesc:gaf095b87aecb2c38ce5014669c70d4f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes real-valued spherical harmonics [1] for each given direction on the unit sphere.  <br /></td></tr>
<tr class="separator:gaf095b87aecb2c38ce5014669c70d4f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2dc357da0a7df362e1d53a91936955c" id="r_gaf2dc357da0a7df362e1d53a91936955c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf2dc357da0a7df362e1d53a91936955c">getMaxREweights</a> (int order, int diagMtxFlag, float *a_n)</td></tr>
<tr class="memdesc:gaf2dc357da0a7df362e1d53a91936955c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weights required to manipulate a hyper-cardioid beam-pattern, such that it has maximum energy in the given look-direction.  <br /></td></tr>
<tr class="separator:gaf2dc357da0a7df362e1d53a91936955c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7fa5744bdd8395ab6d34e238f757599" id="r_gaf7fa5744bdd8395ab6d34e238f757599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf7fa5744bdd8395ab6d34e238f757599">truncationEQ</a> (float *w_n, int order_truncated, int order_target, double *kr, int nBands, float softThreshold, float *gain)</td></tr>
<tr class="memdesc:gaf7fa5744bdd8395ab6d34e238f757599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter that equalises the high frequency roll-off due to SH truncation and tapering; as described in [1].  <br /></td></tr>
<tr class="separator:gaf7fa5744bdd8395ab6d34e238f757599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c5ef22cd1066f447256dcb0ba7f76a2" id="r_ga7c5ef22cd1066f447256dcb0ba7f76a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7c5ef22cd1066f447256dcb0ba7f76a2">getLoudspeakerDecoderMtx</a> (float *ls_dirs_deg, int nLS, <a class="el" href="#gaa9bfe259decc1175b881c63f05edfae2">LOUDSPEAKER_AMBI_DECODER_METHODS</a> method, int order, int enableMaxrE, float *decMtx)</td></tr>
<tr class="memdesc:ga7c5ef22cd1066f447256dcb0ba7f76a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an ambisonic decoding matrix of a specific order, for a given loudspeaker layout.  <br /></td></tr>
<tr class="separator:ga7c5ef22cd1066f447256dcb0ba7f76a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga291c22e193e90d410b9ec3c5f3a01a11" id="r_ga291c22e193e90d410b9ec3c5f3a01a11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga291c22e193e90d410b9ec3c5f3a01a11">getBinauralAmbiDecoderMtx</a> (float_complex *hrtfs, float *hrtf_dirs_deg, int N_dirs, int N_bands, <a class="el" href="#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a> method, int order, float *freqVector, float *itd_s, float *weights, int enableDiffCM, int enableMaxrE, float_complex *decMtx)</td></tr>
<tr class="memdesc:ga291c22e193e90d410b9ec3c5f3a01a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes binaural ambisonic decoding matrices (one per frequency) at a specific order, for a given HRTF set.  <br /></td></tr>
<tr class="separator:ga291c22e193e90d410b9ec3c5f3a01a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa84a59d7917e33747541580167c02e76" id="r_gaa84a59d7917e33747541580167c02e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa84a59d7917e33747541580167c02e76">getBinauralAmbiDecoderFilters</a> (float_complex *hrtfs, float *hrtf_dirs_deg, int N_dirs, int fftSize, float fs, <a class="el" href="#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a> method, int order, float *itd_s, float *weights, int enableDiffCM, int enableMaxrE, float *decFilters)</td></tr>
<tr class="memdesc:gaa84a59d7917e33747541580167c02e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes binaural ambisonic decoding filters for a given HRTF set.  <br /></td></tr>
<tr class="separator:gaa84a59d7917e33747541580167c02e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc8fcc9d1b9981fbc9e6097c97495d4" id="r_ga1cc8fcc9d1b9981fbc9e6097c97495d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1cc8fcc9d1b9981fbc9e6097c97495d4">applyDiffCovMatching</a> (float_complex *hrtfs, float *hrtf_dirs_deg, int N_dirs, int N_bands, int order, float *weights, float_complex *decMtx)</td></tr>
<tr class="memdesc:ga1cc8fcc9d1b9981fbc9e6097c97495d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes a diffuse-field covariance constraint on a given binaural decoding matrix, as described in [1].  <br /></td></tr>
<tr class="separator:ga1cc8fcc9d1b9981fbc9e6097c97495d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Higher-order Ambisonics module. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaeb6116ef26ca8f592af4e81f5f963116" name="gaeb6116ef26ca8f592af4e81f5f963116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb6116ef26ca8f592af4e81f5f963116">&#9670;&#160;</a></span>BINAURAL_AMBI_DECODER_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ambisonic decoding options for binaural/headphone playback. </p>
<dl class="section note"><dt>Note</dt><dd>A more detailed description of each method may be found in <a class="el" href="saf__hoa__internal_8h.html" title="Internal header for the higher-order Ambisonics module (SAF_HOA_MODULE)">saf_hoa_internal.h</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>[1] Z. Ben-Hur, F. Brinkmann, J. Sheaffer, S. Weinzierl, and B. Rafaely, "Spectral equalization in binaural signals represented by order-
         truncated spherical harmonics" The Journal of the Acoustical Society of America, vol. 141, no. 6, pp. 4087&ndash;4096, 2017. </dd>
<dd>
[2] Zaunschirm M, Scho"rkhuber C, Ho"ldrich R. Binaural rendering of Ambisonic signals by head-related impulse response time alignment and a diffuseness constraint. The Journal of the Acoustical Society of America. 2018 Jun 19 143(6) 3616-27 </dd>
<dd>
[3] Scho"rkhuber C, Zaunschirm M, Ho"ldrich R. Binaural Rendering of Ambisonic Signals via Magnitude Least Squares. InProceedings of the DAGA 2018 (Vol. 44, pp. 339-342). </dd>
<dd>
[4] B. Bernschutz, A. V. Giner, C. Po"rschmann, and J. Arend, "Binaural reproduction of plane waves with reduced modal order" Acta Acustica united with Acustica, vol. 100, no. 5, pp. 972&ndash;983, 2014 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116ab9d8239b3e918ada247720015cee827f" name="ggaeb6116ef26ca8f592af4e81f5f963116ab9d8239b3e918ada247720015cee827f"></a>BINAURAL_DECODER_DEFAULT&#160;</td><td class="fielddoc"><p>The default decoder is <a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116a25059f43250b90fb659563953d6e52a4" title="Least-squares (LS) decoder.">BINAURAL_DECODER_LS</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116a25059f43250b90fb659563953d6e52a4" name="ggaeb6116ef26ca8f592af4e81f5f963116a25059f43250b90fb659563953d6e52a4"></a>BINAURAL_DECODER_LS&#160;</td><td class="fielddoc"><p>Least-squares (LS) decoder. </p>
<p>The simplest binaural decoder, which is based on a least-squares fit of the spherical harmonic patterns onto the HRTF directivity patterns. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116aea7d5ff9e0fec9c3e86274cde48a6436" name="ggaeb6116ef26ca8f592af4e81f5f963116aea7d5ff9e0fec9c3e86274cde48a6436"></a>BINAURAL_DECODER_LSDIFFEQ&#160;</td><td class="fielddoc"><p>Least-squares (LS) decoder with diffuse-field spectral equalisation [1]. </p>
<p>Note that the diffuse-field EQ is applied in the spherical harmonic domain (to account for the truncation error/loss of high frequencies), so this is not the same as applying <a class="el" href="group___h_r_i_r.html#gaced04b646c57d04a25e26b469e18588c" title="Applies pre-processing to a set of HRTFs, which can either be diffuse-field EQ of an (optionally weig...">diffuseFieldEqualiseHRTFs()</a> on the HRTFs followed by BINAURAL_DECODER_LS. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116ab52d181ecdf9d10fcb9c5d761cac8a98" name="ggaeb6116ef26ca8f592af4e81f5f963116ab52d181ecdf9d10fcb9c5d761cac8a98"></a>BINAURAL_DECODER_SPR&#160;</td><td class="fielddoc"><p>Spatial resampling decoder (on the same lines as the virtual loudspeaker approach) [4]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457" name="ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457"></a>BINAURAL_DECODER_TA&#160;</td><td class="fielddoc"><p>Time-alignment decoder [2]. </p>
<p>Relies on discarding the phase information of the HRTFs, past the frequency at which humans are less sensitive to inter-aural time difference cues. Therefore, the least-squares fitting priorites matching the interaural level differences (ILDs), rather than the interaural time differences (ITDs). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeb6116ef26ca8f592af4e81f5f963116a02f30e94818bd69708ce020110589ce4" name="ggaeb6116ef26ca8f592af4e81f5f963116a02f30e94818bd69708ce020110589ce4"></a>BINAURAL_DECODER_MAGLS&#160;</td><td class="fielddoc"><p>Magnitude least-squares decoder [3]. </p>
<p>On similar lines to the time- alignment decoder, but differing slightly in its execution. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8h_source.html#l00134">134</a> of file <a class="el" href="saf__hoa_8h_source.html">saf_hoa.h</a>.</p>

</div>
</div>
<a id="ga736d1bf23b9d8a0b2018888b96295591" name="ga736d1bf23b9d8a0b2018888b96295591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga736d1bf23b9d8a0b2018888b96295591">&#9670;&#160;</a></span>HOA_CH_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available Ambisonic channel ordering conventions. </p>
<dl class="section note"><dt>Note</dt><dd>ACN channel ordering with SN3D normalisation is often collectively referred to as the 'AmbiX' format. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>FuMa is a deprecated legacy format and is only supported for first- order! The recommended Ambisonic conventions are ACN with N3D or SN3D normalisation. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga736d1bf23b9d8a0b2018888b96295591a59dc12dec2431faddbf49fa9af554dd7" name="gga736d1bf23b9d8a0b2018888b96295591a59dc12dec2431faddbf49fa9af554dd7"></a>HOA_CH_ORDER_ACN&#160;</td><td class="fielddoc"><p>Ambisonic Channel numbering (ACN) convention, which is employed by all spherical harmonic related functions in SAF. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga736d1bf23b9d8a0b2018888b96295591a2c3c6a04f29de60a9cb2e98853bb0e6e" name="gga736d1bf23b9d8a0b2018888b96295591a2c3c6a04f29de60a9cb2e98853bb0e6e"></a>HOA_CH_ORDER_FUMA&#160;</td><td class="fielddoc"><p>Furse-Malham (FuMa) convention, often used by older recordings. </p>
<p>The convention follows the WXYZ ordering of the omni and dipoles, and is suitable only for 1st order. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8h_source.html#l00183">183</a> of file <a class="el" href="saf__hoa_8h_source.html">saf_hoa.h</a>.</p>

</div>
</div>
<a id="gad26ea0ae544afa82568f7d6a51303f52" name="gad26ea0ae544afa82568f7d6a51303f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad26ea0ae544afa82568f7d6a51303f52">&#9670;&#160;</a></span>HOA_NORM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available Ambisonic normalisation conventions. </p>
<dl class="section note"><dt>Note</dt><dd>ACN channel ordering with SN3D normalisation is often collectively referred to as the 'AmbiX' format. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>FuMa is a deprecated legacy format and is only supported for first- order! The recommended Ambisonic conventions are ACN with N3D/SN3D normalisation. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad26ea0ae544afa82568f7d6a51303f52afd66a843a7e726beb405e37649bc24d6" name="ggad26ea0ae544afa82568f7d6a51303f52afd66a843a7e726beb405e37649bc24d6"></a>HOA_NORM_N3D&#160;</td><td class="fielddoc"><p>Orthonormalised (N3D) convention, which is the default convention used by SAF. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad26ea0ae544afa82568f7d6a51303f52a9f7d4d31d27255bf7df49c21234b82e4" name="ggad26ea0ae544afa82568f7d6a51303f52a9f7d4d31d27255bf7df49c21234b82e4"></a>HOA_NORM_SN3D&#160;</td><td class="fielddoc"><p>Schmidt semi-normalisation (SN3D) convention, as used by the AmbiX standard. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad26ea0ae544afa82568f7d6a51303f52a5f31b11f5e519ab3fb25ecc2d7eaee93" name="ggad26ea0ae544afa82568f7d6a51303f52a5f31b11f5e519ab3fb25ecc2d7eaee93"></a>HOA_NORM_FUMA&#160;</td><td class="fielddoc"><p>Furse-Malham (FuMa) convention. </p>
<p>This is similar to SN3D (at first-order), except theres an additional 1/sqrt(2) scaling applied to the omni. This is also known as maxN normalisation. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8h_source.html#l00203">203</a> of file <a class="el" href="saf__hoa_8h_source.html">saf_hoa.h</a>.</p>

</div>
</div>
<a id="gaa9bfe259decc1175b881c63f05edfae2" name="gaa9bfe259decc1175b881c63f05edfae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9bfe259decc1175b881c63f05edfae2">&#9670;&#160;</a></span>LOUDSPEAKER_AMBI_DECODER_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaa9bfe259decc1175b881c63f05edfae2">LOUDSPEAKER_AMBI_DECODER_METHODS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ambisonic decoding options for loudspeaker playback. </p>
<p>Note that the MMD and EPAD decoding options revert back to "SAD" if the loudspeakers are uniformly distributed on the sphere. The benefits afforded by MMD, EPAD [1], and AllRAD [2] relate to their improved performance when using irregular loudspeaker arrangements.</p>
<dl class="section see"><dt>See also</dt><dd>[1] Zotter F, Pomberger H, Noisternig M. Energy&ndash;preserving ambisonic decoding. Acta Acustica united with Acustica. 2012 Jan 1; 98(1):37-47. </dd>
<dd>
[2] Zotter F, Frank M. All-round ambisonic panning and decoding. Journal of the audio engineering society. 2012 Nov 26; 60(10):807-20. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa9bfe259decc1175b881c63f05edfae2aa1dad6c278efa25907a0b64fb2942e26" name="ggaa9bfe259decc1175b881c63f05edfae2aa1dad6c278efa25907a0b64fb2942e26"></a>LOUDSPEAKER_DECODER_DEFAULT&#160;</td><td class="fielddoc"><p>The default decoder is <a class="el" href="#ggaa9bfe259decc1175b881c63f05edfae2a743482262e1deb4c4511d2a9cbaddff6" title="Sampling Ambisonic Decoder (SAD): transpose of the loudspeaker spherical harmonic matrix,...">LOUDSPEAKER_DECODER_SAD</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9bfe259decc1175b881c63f05edfae2a743482262e1deb4c4511d2a9cbaddff6" name="ggaa9bfe259decc1175b881c63f05edfae2a743482262e1deb4c4511d2a9cbaddff6"></a>LOUDSPEAKER_DECODER_SAD&#160;</td><td class="fielddoc"><p>Sampling Ambisonic Decoder (SAD): transpose of the loudspeaker spherical harmonic matrix, scaled by the number of loudspeakers. </p>
<p>This is the simplest decoding approach, as it essentially just generates hyper- cardioid beamformers (aka virtual microphones) towards each loudspeaker direction. This approach is numerically robust to irregular loudspeaker arrangements. However, it does not preserve the energy of a source (or localisation cues) as it is panned around in different directions over irregular setups. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9bfe259decc1175b881c63f05edfae2ae1f628a0188a79ae586ae270a0a8b508" name="ggaa9bfe259decc1175b881c63f05edfae2ae1f628a0188a79ae586ae270a0a8b508"></a>LOUDSPEAKER_DECODER_MMD&#160;</td><td class="fielddoc"><p>Mode-Matching Decoder (MMD): pseudo-inverse of the loudspeaker spherical harmonic matrix. </p>
<p>Due to the pseudo-inverse, more signal energy is lent to regions on the surface of the sphere that are more sparsely populated with loudspeakers; (this is essentially a least-squares solution). Therefore, this approach can help balance out directional loudness differences when using slightly irregular setups. However, one must also be careful since loudspeakers that are very far way from all the other loudspeakers (e.g. voice-of-god) may be given significantly more signal energy than expected. Therefore, this approach is not recommended for highly irregular loudspeaker arrangements! </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9bfe259decc1175b881c63f05edfae2aa1e10487b21890502a1c72b34d2b7add" name="ggaa9bfe259decc1175b881c63f05edfae2aa1e10487b21890502a1c72b34d2b7add"></a>LOUDSPEAKER_DECODER_EPAD&#160;</td><td class="fielddoc"><p>Energy-Preserving Ambisonic Decoder (EPAD) [1]. </p>
<p>This decoder aims to preserve the energy of a source, as it panned around to directions of the sphere; essentially, addressing the energy-preserving issues of the SAD and MMD decoding approaches for irregular layouts. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9bfe259decc1175b881c63f05edfae2a30fc2a59a858885b6651fd5a1fd34145" name="ggaa9bfe259decc1175b881c63f05edfae2a30fc2a59a858885b6651fd5a1fd34145"></a>LOUDSPEAKER_DECODER_ALLRAD&#160;</td><td class="fielddoc"><p>All-Round Ambisonic Decoder (AllRAD): SAD decoding to a t-design, panned for the target loudspeaker directions using VBAP [2]. </p>
<p>Perhaps the Ambisonic decoder we would most recommend for irregular loudspeaker layouts. Note, given a high (well... technically infinite) order, AllRAD will converge to VBAP. However, since lower-orders are employed in practice, AllRAD is not as spatially "sharp" as VBAP, but it will yield more consistent source spread when panning a source inbetween the loudspeakers. The approach is highly robust to irregular loudspeaker setups, and exhibits low directional error and good energy-preserving properties. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8h_source.html#l00061">61</a> of file <a class="el" href="saf__hoa_8h_source.html">saf_hoa.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1cc8fcc9d1b9981fbc9e6097c97495d4" name="ga1cc8fcc9d1b9981fbc9e6097c97495d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc8fcc9d1b9981fbc9e6097c97495d4">&#9670;&#160;</a></span>applyDiffCovMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void applyDiffCovMatching </td>
          <td>(</td>
          <td class="paramtype">float_complex *</td>          <td class="paramname"><span class="paramname"><em>hrtfs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>hrtf_dirs_deg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N_dirs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N_bands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *</td>          <td class="paramname"><span class="paramname"><em>decMtx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imposes a diffuse-field covariance constraint on a given binaural decoding matrix, as described in [1]. </p>
<dl class="section note"><dt>Note</dt><dd>decMtx is altered in-place.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtfs</td><td>The HRTFs; FLAT: N_bands x <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x N_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtf_dirs_deg</td><td>HRTF directions; FLAT: N_dirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_dirs</td><td>Number of HRTF directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_bands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Integration weights (set to NULL if not available); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">decMtx</td><td>Decoding matrix; FLAT: N_bands x <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x (order+1)^2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Zaunschirm M, Scho"rkhuber C, Ho"ldrich R. Binaural rendering of Ambisonic signals by head-related impulse response time alignment and a diffuseness constraint. The Journal of the Acoustical Society of America. 2018 Jun 19;143(6):3616-27 </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00502">502</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="ga567162a2a735a8c95be9729d40c1c1d9" name="ga567162a2a735a8c95be9729d40c1c1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga567162a2a735a8c95be9729d40c1c1d9">&#9670;&#160;</a></span>convertHOAChannelConvention()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void convertHOAChannelConvention </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>insig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>signalLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a></td>          <td class="paramname"><span class="paramname"><em>inConvention</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga736d1bf23b9d8a0b2018888b96295591">HOA_CH_ORDER</a></td>          <td class="paramname"><span class="paramname"><em>outConvention</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an Ambisonic signal from one channel ordering convention to another. </p>
<dl class="section warning"><dt>Warning</dt><dd>If one of the in/out conventions is FuMa, then only the first 4 channels are converted, and any remaining channels of 'insig' are set to zeros (i.e. FuMa is strictly first-order only in SAF). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>insig is converted "in-place". Also, if the in/out conventions are the same, then the function is bypassed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">insig</td><td>Input signal with the channel ordering convention of: inConvention; FLAT: (order+1)^2 x signalLength </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Ambisonic order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalLength</td><td>Signal length in samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inConvention</td><td>Channel order convention of input signals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outConvention</td><td>Channel order convention of output signals </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00040">40</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gae64fac66ae4e7564551f1f04378726d4" name="gae64fac66ae4e7564551f1f04378726d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae64fac66ae4e7564551f1f04378726d4">&#9670;&#160;</a></span>convertHOANormConvention()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void convertHOANormConvention </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>insig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>signalLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a></td>          <td class="paramname"><span class="paramname"><em>inConvention</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gad26ea0ae544afa82568f7d6a51303f52">HOA_NORM</a></td>          <td class="paramname"><span class="paramname"><em>outConvention</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an Ambisonic signal from one normalisation convention to another. </p>
<dl class="section warning"><dt>Warning</dt><dd>If one of the in/out conventions is FuMa, then only the first 4 channels are converted, and any remaining channels of 'insig' are set to zeros (FuMa is strictly first-order only in SAF). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>insig is converted "in-place". Also, if the in/out conventions are the same, then the function is bypassed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">insig</td><td>Input signal with the channel ordering convention of: inConvention, which should be converted to: outConvention, "in-place"; FLAT: (order+1)^2 x signalLength </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Ambisonic order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalLength</td><td>Signal length in samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inConvention</td><td>Normalisation convention of the input signals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outConvention</td><td>Normalisation convention of the output signals </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00072">72</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gaa84a59d7917e33747541580167c02e76" name="gaa84a59d7917e33747541580167c02e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa84a59d7917e33747541580167c02e76">&#9670;&#160;</a></span>getBinauralAmbiDecoderFilters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getBinauralAmbiDecoderFilters </td>
          <td>(</td>
          <td class="paramtype">float_complex *</td>          <td class="paramname"><span class="paramname"><em>hrtfs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>hrtf_dirs_deg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N_dirs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fftSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>fs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a></td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>itd_s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>enableDiffCM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>enableMaxrE</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>decFilters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes binaural ambisonic decoding filters for a given HRTF set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtfs</td><td>The HRTFs; FLAT: (fftSize/2+1) x <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x N_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtf_dirs_deg</td><td>HRTF directions; FLAT: N_dirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_dirs</td><td>Number of HRTF directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fftSize</td><td>FFT size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fs</td><td>Sampling rate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Decoder method (see <a class="el" href="#gaeb6116ef26ca8f592af4e81f5f963116" title="Ambisonic decoding options for binaural/headphone playback.">BINAURAL_AMBI_DECODER_METHODS</a> enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itd_s</td><td>Only needed for <a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457" title="Time-alignment decoder [2].">BINAURAL_DECODER_TA</a> decoder (can set to NULL if using different method); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Integration weights (set to NULL if not available); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableDiffCM</td><td>Set to '0' to disable diffuse correction, '1' to enable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableMaxrE</td><td>Set to '0' to disable maxRE weighting, '1' to enable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decFilters</td><td>Decoding filters; FLAT: <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x (order+1)^2 x fftSize </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00452">452</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="ga291c22e193e90d410b9ec3c5f3a01a11" name="ga291c22e193e90d410b9ec3c5f3a01a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga291c22e193e90d410b9ec3c5f3a01a11">&#9670;&#160;</a></span>getBinauralAmbiDecoderMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getBinauralAmbiDecoderMtx </td>
          <td>(</td>
          <td class="paramtype">float_complex *</td>          <td class="paramname"><span class="paramname"><em>hrtfs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>hrtf_dirs_deg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N_dirs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N_bands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaeb6116ef26ca8f592af4e81f5f963116">BINAURAL_AMBI_DECODER_METHODS</a></td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>freqVector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>itd_s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>enableDiffCM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>enableMaxrE</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *</td>          <td class="paramname"><span class="paramname"><em>decMtx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes binaural ambisonic decoding matrices (one per frequency) at a specific order, for a given HRTF set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtfs</td><td>The HRTFs; FLAT: N_bands x <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x N_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtf_dirs_deg</td><td>HRTF directions; FLAT: N_dirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_dirs</td><td>Number of HRTF directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_bands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Decoder method (see <a class="el" href="#gaeb6116ef26ca8f592af4e81f5f963116" title="Ambisonic decoding options for binaural/headphone playback.">BINAURAL_AMBI_DECODER_METHODS</a> enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freqVector</td><td>Only needed for <a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457" title="Time-alignment decoder [2].">BINAURAL_DECODER_TA</a> or <a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116a02f30e94818bd69708ce020110589ce4" title="Magnitude least-squares decoder [3].">BINAURAL_DECODER_MAGLS</a> decoders (set to NULL if using a different method); N_bands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itd_s</td><td>Only needed for <a class="el" href="#ggaeb6116ef26ca8f592af4e81f5f963116ad06de101e3b304af994c611b744df457" title="Time-alignment decoder [2].">BINAURAL_DECODER_TA</a> decoder (set to NULL if using different method); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Integration weights (set to NULL if not available); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableDiffCM</td><td>Set to '0' to disable diffuse correction, '1' to enable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableMaxrE</td><td>Set to '0' to disable maxRE weighting, '1' to enable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decMtx</td><td>Decoding matrices (one per frequency); FLAT: N_bands x <a class="el" href="group___utilities.html#ga39b45c9e65aebd2a8ef72c3081baea84" title="2 (true for most humans)">NUM_EARS</a> x (order+1)^2 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00394">394</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="ga7c5ef22cd1066f447256dcb0ba7f76a2" name="ga7c5ef22cd1066f447256dcb0ba7f76a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c5ef22cd1066f447256dcb0ba7f76a2">&#9670;&#160;</a></span>getLoudspeakerDecoderMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getLoudspeakerDecoderMtx </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>ls_dirs_deg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nLS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa9bfe259decc1175b881c63f05edfae2">LOUDSPEAKER_AMBI_DECODER_METHODS</a></td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>enableMaxrE</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>decMtx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an ambisonic decoding matrix of a specific order, for a given loudspeaker layout. </p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000020">Test</a></b></dt><dd><a class="el" href="saf__test_8h.html#a5e73f4abcab45bb014c621804a6864a6" title="Testing to assure that (given a uniform loudspeaker layout), the SAD, MMD and EPAD decoders are all e...">test__getLoudspeakerDecoderMtx()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ls_dirs_deg</td><td>Loudspeaker directions in DEGREES [azi elev]; FLAT: nLS x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLS</td><td>Number of loudspeakers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Decoding method (see <a class="el" href="#gaa9bfe259decc1175b881c63f05edfae2" title="Ambisonic decoding options for loudspeaker playback.">LOUDSPEAKER_AMBI_DECODER_METHODS</a> enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableMaxrE</td><td>Set to '0' to disable, '1' to enable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decMtx</td><td>Decoding matrix; FLAT: nLS x (order+1)^2 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00326">326</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gaf2dc357da0a7df362e1d53a91936955c" name="gaf2dc357da0a7df362e1d53a91936955c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2dc357da0a7df362e1d53a91936955c">&#9670;&#160;</a></span>getMaxREweights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getMaxREweights </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>diagMtxFlag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>a_n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weights required to manipulate a hyper-cardioid beam-pattern, such that it has maximum energy in the given look-direction. </p>
<p>Due to the side and back lobes of the beamformers employed by the Ambisonic decoder, when panning a source there can be unwanted energy given to loudspeakers directly opposite the true source direction. This max_rE weighting [1] essentially spatially tapers the spherical harmonic components used to generate the beamformers, thus reducing the contribution of the higher order components. This results in worse spatial selectivity, as the width of the beam pattern main lobe is widened, however, the back lobes are also reduced, thus mitigating perceptual issues that may arise due to the aforementioned problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagMtxFlag</td><td>Set to '0' if you want the weights to be returned as a vector, or to '1' as a diagonal matrix instead. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_n</td><td>The max_rE weights, as a vector/diagonal matrix; (order+1)^2 x 1 OR FLAT: (order+1)^2 x (order+1)^2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Zotter F, Frank M. All-round ambisonic panning and decoding. Journal of the audio engineering society. 2012 Nov 26; 60(10):807-20. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00235">235</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gac2804e1b897727e3ed1cd0d6dc74d179" name="gac2804e1b897727e3ed1cd0d6dc74d179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2804e1b897727e3ed1cd0d6dc74d179">&#9670;&#160;</a></span>getRSH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRSH </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>dirs_deg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nDirs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes real-valued spherical harmonics [1] for each given direction on the unit sphere. </p>
<p>The spherical harmonic values are computed WITHOUT the 1/sqrt(4*pi) term. Compared to <a class="el" href="#gaf095b87aecb2c38ce5014669c70d4f6f" title="Computes real-valued spherical harmonics [1] for each given direction on the unit sphere.">getRSH_recur()</a>, this function uses <a class="el" href="group___s_h.html#ga1ff15ddf9e257b1f185421568ef349dd" title="Calculates unnormalised Legendre polynomials up to order N, for all values in vector x [1].">unnorm_legendreP()</a> and double precision, so is more suitable for being computed in an initialisation stage. This version is indeed slower, but more precise (especially for high orders).</p>
<dl class="section note"><dt>Note</dt><dd>This function is mainly intended for Ambisonics, due to the omission of the 1/sqrt(4*pi) scaling, and the directions are given in [azimuth elevation] (degrees). In Ambisonics literature, the format convention of 'Y' is referred to as ACN/N3D</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_deg</td><td>Directions on the sphere [azi, ELEVATION] convention, in DEGREES; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITHOUT the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00118">118</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gaf095b87aecb2c38ce5014669c70d4f6f" name="gaf095b87aecb2c38ce5014669c70d4f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf095b87aecb2c38ce5014669c70d4f6f">&#9670;&#160;</a></span>getRSH_recur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRSH_recur </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>dirs_deg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nDirs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes real-valued spherical harmonics [1] for each given direction on the unit sphere. </p>
<p>The real spherical harmonics are computed WITHOUT the 1/sqrt(4*pi) term. Compared to <a class="el" href="#gac2804e1b897727e3ed1cd0d6dc74d179" title="Computes real-valued spherical harmonics [1] for each given direction on the unit sphere.">getRSH()</a>, this function uses <a class="el" href="group___s_h.html#ga3851842c7f6c520c3f645f0ae686443c" title="Calculates unnormalised Legendre polynomials up to order N, for all values in vector x.">unnorm_legendreP_recur()</a> and single precision, so is more suitable for being computed in a real-time loop. It sacrifices some precision, and numerical error propogates through the recursion, but it is much faster.</p>
<p>The function also uses static memory buffers for single direction and up to 7th order, which speeds things up considerably for such use cases.</p>
<dl class="section note"><dt>Note</dt><dd>This function is mainly intended for Ambisonics, due to the omission of the 1/sqrt(4*pi) scaling, and the directions are given in [azimuth elevation] (degrees). In Ambisonics literature, the format convention of 'Y' is referred to as ACN/N3D</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_deg</td><td>Directions on the sphere [azi, ELEVATION] convention, in DEGREES; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITHOUT the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00152">152</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
<a id="gaf7fa5744bdd8395ab6d34e238f757599" name="gaf7fa5744bdd8395ab6d34e238f757599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7fa5744bdd8395ab6d34e238f757599">&#9670;&#160;</a></span>truncationEQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void truncationEQ </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>w_n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order_truncated</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order_target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>kr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nBands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>softThreshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>gain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter that equalises the high frequency roll-off due to SH truncation and tapering; as described in [1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w_n</td><td>Tapering weights; (order_truncated + 1) x 1 E.g. maxRE, or all ones for truncation only </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order_truncated</td><td>Input SH order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order_target</td><td>Target SH order, (should be higher, e.g. 38) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>kr vector, r e.g. 0.085 m; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softThreshold</td><td>Threshold in dB, soft limiting above to +6dB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gain</td><td>Gain factor for compensation filter; nBands x 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Hold, C., Gamper, H., Pulkki, V., Raghuvanshi, N., &amp; Tashev, I. J. (2019). Improving Binaural Ambisonics Decoding by Spherical Harmonics Domain Tapering and Coloration Compensation. ICASSP, IEEE International Conference on Acoustics, Speech and Signal Processing - Proceedings. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__hoa_8c_source.html#l00269">269</a> of file <a class="el" href="saf__hoa_8c_source.html">saf_hoa.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 27 2025 08:29:46 for SAF by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
      $(document).ready(function(){
         toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
         toggleButton.title = "Toggle Light/Dark Mode"
         document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
     })
  })
</script>
</body>
</html>
